<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ifuryst.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ifuryst.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2025-05-19T02:47:05+00:00</updated><id>https://ifuryst.github.io/feed.xml</id><title type="html">ifuryst</title><subtitle>📝 &amp; 💭 </subtitle><entry><title type="html">MCP鉴权</title><link href="https://ifuryst.github.io/blog/2025/mcp-authorization/" rel="alternate" type="text/html" title="MCP鉴权"/><published>2025-05-12T05:30:00+00:00</published><updated>2025-05-12T05:30:00+00:00</updated><id>https://ifuryst.github.io/blog/2025/mcp-authorization</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/mcp-authorization/"><![CDATA[<p>官方新的<a href="https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization#2-3-1-server-metadata-discovery-headers">修订版本</a>支持了OAuth2的鉴权方式，我们一起来看看</p> <p>首先是协议要求：</p> <ul> <li>STDIO不支持，STDIO只支持通过env传入</li> <li>SSE/Streamable HTTP应该支持（非强制性）</li> </ul> <p>MCP遵循了OAuth2的标准，主要涉及：</p> <ul> <li><a href="https://datatracker.ietf.org/doc/html/draft-ietf-oauth-v2-1-12"><strong>OAuth 2.1 IETF DRAFT</strong></a></li> <li>OAuth 2.0 Authorization Server Metadata (<a href="https://datatracker.ietf.org/doc/html/rfc8414"><strong>RFC8414</strong></a>)</li> <li>OAuth 2.0 Dynamic Client Registration Protocol (<a href="https://datatracker.ietf.org/doc/html/rfc7591"><strong>RFC7591</strong></a>)</li> </ul> <p>其中OAuth2.1还在草案阶段，还没成为正式的RFC标准。这边我们简单汇总一下OAuth相关的RFC</p> <table> <thead> <tr> <th>标准/草案</th> <th>类型</th> <th>状态</th> <th>是否核心</th> <th>简介</th> </tr> </thead> <tbody> <tr> <td>RFC 6749</td> <td>OAuth 2.0 框架</td> <td>✅ 已发布</td> <td>✅ 是</td> <td>定义了授权流程（授权码、隐式、密码、客户端凭证）和四大角色（客户端、资源拥有者、授权服务器、资源服务器）</td> </tr> <tr> <td>RFC 6750</td> <td>Bearer Token 使用</td> <td>✅ 已发布</td> <td>✅ 是</td> <td>描述如何在 HTTP 中安全使用访问令牌（Bearer Token）</td> </tr> <tr> <td>RFC 7591</td> <td>动态客户端注册</td> <td>✅ 已发布</td> <td>❌ 扩展</td> <td>允许客户端通过 API 动态注册到授权服务器</td> </tr> <tr> <td>RFC 8414</td> <td>授权服务器元数据</td> <td>✅ 已发布</td> <td>❌ 扩展</td> <td>提供 .well-known 端点用于公开服务器配置信息，支持自动发现</td> </tr> <tr> <td>draft-ietf-oauth-v2-1</td> <td>OAuth 2.1 草案</td> <td>⏳ 草案中</td> <td>✅ 拟核心</td> <td>汇总和更新 OAuth 2.0 核心内容，合并并替代 RFC 6749 和 RFC 6750，剔除不安全授权方式（如隐式授权）并强制使用 PKCE</td> </tr> </tbody> </table> <h2 id="oauth-20--21">OAuth 2.0 &amp; 2.1</h2> <h3 id="oauth-20---rfc-6749--rfc-6750">OAuth 2.0 - RFC 6749 &amp; RFC 6750</h3> <p>这边简单过一下OAuth的内容，RFC 6749，涉及了OAuth2.0的定义，我们就关注重要的</p> <ol> <li>注册Client，获得ClientID和ClientSecret</li> <li> <p>配置在Client上，需要授权的时候，Client（通常是浏览器）跳转/authorize要求用户授权</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /authorize?
  <span class="nv">response_type</span><span class="o">=</span>code&amp;
  <span class="nv">client_id</span><span class="o">=</span>abc123&amp;
  <span class="nv">redirect_uri</span><span class="o">=</span>https://client.com/callback&amp;
  <span class="nv">scope</span><span class="o">=</span><span class="nb">read </span>write&amp;
  <span class="nv">state</span><span class="o">=</span>xyz123
</code></pre></div> </div> </li> <li> <p>授权服务器重定向并带回code</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HTTP/1.1 302 Found
Location: https://client.com/callback?code<span class="o">=</span>SplxlOBeZQQYbYS6WxSbIA&amp;state<span class="o">=</span>xyz123
</code></pre></div> </div> </li> <li> <p>Client或者Server用授权吗code去换AccessToken和RefreshToken</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /token
Content-Type: application/x-www-form-urlencoded

<span class="nv">grant_type</span><span class="o">=</span>authorization_code&amp;
<span class="nv">code</span><span class="o">=</span>SplxlOBeZQQYbYS6WxSbIA&amp;
<span class="nv">redirect_uri</span><span class="o">=</span>https%3A%2F%2Fclient.com%2Fcallback&amp;
<span class="nv">client_id</span><span class="o">=</span>abc123&amp;
<span class="nv">client_secret</span><span class="o">=</span>secret456
</code></pre></div> </div> </li> <li> <p>使用token就可以去请求对应的资源了（根据scope决定资源范围）</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
  <span class="s2">"access_token"</span>: <span class="s2">"2YotnFZFEjr1zCsicMWpAA"</span>,
  <span class="s2">"token_type"</span>: <span class="s2">"Bearer"</span>,
  <span class="s2">"expires_in"</span>: 3600,
  <span class="s2">"refresh_token"</span>: <span class="s2">"tGzv3JOkF0XG5Qx2TlKWIA"</span>
<span class="o">}</span>
</code></pre></div> </div> </li> </ol> <p>RFC 6750基本就是对OAuth 2.0进行补充了，主要就是AccessToken用Bearer Token来表示（Authorization: Bearer <token>）。这里需要注意的是，不一定是JWT，很多地方用了JWT但是Bearer Token不等价于JWT，可能是JWT也可能是一串随机的字符串</token></p> <h3 id="oauth-20-authorization-server-metadata---rfc-8414">OAuth 2.0 Authorization Server Metadata - RFC 8414</h3> <p>前面提到的/authorize /token 这类端点都是固定的，或者提前约定配置好的，有些场景就不方便，因此这份RFC提供了一个自动发现的机制，有点类似OIDC中的openid-configuration</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET https://auth.example.com/.well-known/oauth-authorization-server

<span class="c"># 多租户</span>
GET https://auth.example.com/.well-known/oauth-authorization-server?issuer<span class="o">=</span>https://issuer.example.com
</code></pre></div></div> <p>就是增加这个端点（就是Discovery Endpoint，.well-known/oauth-authorization-server），用于发现相关的配置，配置（就是Metadata Document，JSON格式的授权服务器元数据）可能如下：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
  <span class="s2">"issuer"</span>: <span class="s2">"https://mcp-github-oauth.ifuryst.workers.dev"</span>,
  <span class="s2">"authorization_endpoint"</span>: <span class="s2">"https://mcp-github-oauth.ifuryst.workers.dev/authorize"</span>,
  <span class="s2">"token_endpoint"</span>: <span class="s2">"https://mcp-github-oauth.ifuryst.workers.dev/token"</span>,
  <span class="s2">"registration_endpoint"</span>: <span class="s2">"https://mcp-github-oauth.ifuryst.workers.dev/register"</span>,
  <span class="s2">"response_types_supported"</span>: <span class="o">[</span>
    <span class="s2">"code"</span>
  <span class="o">]</span>,
  <span class="s2">"response_modes_supported"</span>: <span class="o">[</span>
    <span class="s2">"query"</span>
  <span class="o">]</span>,
  <span class="s2">"grant_types_supported"</span>: <span class="o">[</span>
    <span class="s2">"authorization_code"</span>,
    <span class="s2">"refresh_token"</span>
  <span class="o">]</span>,
  <span class="s2">"token_endpoint_auth_methods_supported"</span>: <span class="o">[</span>
    <span class="s2">"client_secret_basic"</span>,
    <span class="s2">"client_secret_post"</span>,
    <span class="s2">"none"</span>
  <span class="o">]</span>,
  <span class="s2">"revocation_endpoint"</span>: <span class="s2">"https://mcp-github-oauth.ifuryst.workers.dev/token"</span>,
  <span class="s2">"code_challenge_methods_supported"</span>: <span class="o">[</span>
    <span class="s2">"plain"</span>,
    <span class="s2">"S256"</span>
  <span class="o">]</span>
<span class="o">}</span>
</code></pre></div></div> <table> <thead> <tr> <th>字段名</th> <th>是否必需</th> <th>类型</th> <th>说明</th> </tr> </thead> <tbody> <tr> <td>issuer</td> <td>✅ 是</td> <td>string</td> <td>授权服务器的唯一标识符（URL），必须是 https，不能带参数或 fragment</td> </tr> <tr> <td>authorization_endpoint</td> <td>✅ 是（除非不支持基于授权码的 flow）</td> <td>string</td> <td>OAuth 授权端点地址，用于获取用户授权</td> </tr> <tr> <td>token_endpoint</td> <td>✅ 是（除非只支持 implicit）</td> <td>string</td> <td>Token 端点，客户端在此获取 access token</td> </tr> <tr> <td>jwks_uri</td> <td>⛔ 可选</td> <td>string</td> <td>JWK Set 的地址，包含公钥供客户端验证 JWT 签名</td> </tr> <tr> <td>registration_endpoint</td> <td>⛔ 可选</td> <td>string</td> <td>支持动态客户端注册时用于注册客户端的端点</td> </tr> <tr> <td>scopes_supported</td> <td>⛔ 推荐</td> <td>array</td> <td>支持的 scope 列表</td> </tr> <tr> <td>response_types_supported</td> <td>✅ 是</td> <td>array</td> <td>支持的响应类型，如 code、token</td> </tr> <tr> <td>response_modes_supported</td> <td>⛔ 可选</td> <td>array</td> <td>支持的 response mode，如 query、fragment、form_post</td> </tr> <tr> <td>grant_types_supported</td> <td>⛔ 可选</td> <td>array</td> <td>支持的授权类型，如 authorization_code、client_credentials</td> </tr> <tr> <td>token_endpoint_auth_methods_supported</td> <td>⛔ 可选</td> <td>array</td> <td>token endpoint 支持的客户端认证方式，如 client_secret_basic</td> </tr> <tr> <td>token_endpoint_auth_signing_alg_values_supported</td> <td>⛔ 可选</td> <td>array</td> <td>token endpoint 使用 JWT 认证时支持的签名算法，如 RS256</td> </tr> <tr> <td>service_documentation</td> <td>⛔ 可选</td> <td>string</td> <td>开发者文档地址</td> </tr> <tr> <td>ui_locales_supported</td> <td>⛔ 可选</td> <td>array</td> <td>UI 支持的语言列表（如 zh-CN）</td> </tr> <tr> <td>op_policy_uri</td> <td>⛔ 可选</td> <td>string</td> <td>授权服务器对客户端使用数据的策略说明 URL</td> </tr> <tr> <td>op_tos_uri</td> <td>⛔ 可选</td> <td>string</td> <td>服务条款 URL</td> </tr> <tr> <td>revocation_endpoint</td> <td>⛔ 可选</td> <td>string</td> <td>token 撤销端点（见 RFC 7009）</td> </tr> <tr> <td>revocation_endpoint_auth_methods_supported</td> <td>⛔ 可选</td> <td>array</td> <td>revocation endpoint 支持的认证方式</td> </tr> <tr> <td>revocation_endpoint_auth_signing_alg_values_supported</td> <td>⛔ 可选</td> <td>array</td> <td>revocation endpoint 支持的 JWT 签名算法</td> </tr> <tr> <td>introspection_endpoint</td> <td>⛔ 可选</td> <td>string</td> <td>token 状态检查端点（见 RFC 7662）</td> </tr> <tr> <td>introspection_endpoint_auth_methods_supported</td> <td>⛔ 可选</td> <td>array</td> <td>introspection endpoint 支持的认证方式</td> </tr> <tr> <td>introspection_endpoint_auth_signing_alg_values_supported</td> <td>⛔ 可选</td> <td>array</td> <td>introspection endpoint 支持的 JWT 签名算法</td> </tr> <tr> <td>code_challenge_methods_supported</td> <td>⛔ 可选</td> <td>array</td> <td>支持的 PKCE code_challenge_method（如 S256）</td> </tr> </tbody> </table> <p>另外服务商还可以增加自定义字段</p> <h3 id="oauth-20-dynamic-client-registration-protocol---rfc-7591">OAuth 2.0 Dynamic Client Registration Protocol - RFC 7591</h3> <p>之前注册获得ClientID的步骤是手动的，这个RFC本质上就是让客户端可以自动注册自身拿到ClientID和ClientSecret，而不需要人为提前注册</p> <p>注册示例</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /register HTTP/1.1
Host: server.example.com
Content-Type: application/json

<span class="o">{</span>
  <span class="s2">"client_name"</span>: <span class="s2">"AwesomeApp"</span>,
  <span class="s2">"redirect_uris"</span>: <span class="o">[</span>
    <span class="s2">"https://awesome.example.com/oauth/callback"</span>
  <span class="o">]</span>,
  <span class="s2">"grant_types"</span>: <span class="o">[</span><span class="s2">"authorization_code"</span>, <span class="s2">"refresh_token"</span><span class="o">]</span>,
  <span class="s2">"response_types"</span>: <span class="o">[</span><span class="s2">"code"</span><span class="o">]</span>,
  <span class="s2">"scope"</span>: <span class="s2">"read write"</span>,
  <span class="s2">"token_endpoint_auth_method"</span>: <span class="s2">"client_secret_basic"</span>
<span class="o">}</span>
</code></pre></div></div> <p>可能会返回</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">{</span>
  <span class="s2">"client_id"</span>: <span class="s2">"s6BhdRkqt3"</span>,
  <span class="s2">"client_secret"</span>: <span class="s2">"7Fjfp0ZBr1KtDRbnfVdmIw"</span>,
  <span class="s2">"registration_access_token"</span>: <span class="s2">"access-token-123"</span>,
  <span class="s2">"registration_client_uri"</span>: <span class="s2">"https://server.example.com/register/s6BhdRkqt3"</span>,
  <span class="s2">"client_id_issued_at"</span>: 1599389946,
  <span class="s2">"client_secret_expires_at"</span>: 0
<span class="o">}</span>
</code></pre></div></div> <h3 id="oauth-21">OAuth 2.1</h3> <p>对OAuth 2.0进行修订，而不是完全重写，主要差异：</p> <ul> <li>Implicit和Resource Owner Password Credentials方式因不安全被移除了</li> <li>强制所有客户端都需要使用PKCE</li> <li>推荐refresh token启用rotation（也就是刷新时会废弃旧的）</li> </ul> <p>我觉得这里最重要的明显差异就是强制使用PKCE(Proof Key for Code Exchange)，为了防止授权码被拦截重放而设计的机制，大体是:</p> <ol> <li>客户端随机生成一串字符串，这串字符串就是code_verifier</li> <li>将code_verifier进行SHA256哈希后Base64编码，就可以得到另外一串随机字符串，就是code_challenge</li> <li>客户端请求的时候就可以发送code_challenge和对应的哈希算法code_challenge_method=S256</li> <li>用户同意授权后，服务端记录code_challenge</li> <li>客户端用authorization_code换token的时候，要带上原始的code_verifier</li> <li>授权服务会对code_verifier哈希后对比，以确认是否接受请求</li> </ol> <p>通过代码看看</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="n">secrets</span>
<span class="kn">import</span> <span class="n">hashlib</span>
<span class="kn">import</span> <span class="n">base64</span>

<span class="k">def</span> <span class="nf">generate_code_verifier</span><span class="p">(</span><span class="n">length</span><span class="o">=</span><span class="mi">64</span><span class="p">):</span>
    <span class="c1"># PKCE 规范推荐长度在 43～128 字符之间
</span>    <span class="k">return</span> <span class="n">base64</span><span class="p">.</span><span class="nf">urlsafe_b64encode</span><span class="p">(</span><span class="n">secrets</span><span class="p">.</span><span class="nf">token_bytes</span><span class="p">(</span><span class="n">length</span><span class="p">)).</span><span class="nf">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">=</span><span class="sh">'</span><span class="p">).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">generate_code_challenge</span><span class="p">(</span><span class="n">code_verifier</span><span class="p">):</span>
    <span class="n">code_verifier_bytes</span> <span class="o">=</span> <span class="n">code_verifier</span><span class="p">.</span><span class="nf">encode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span>
    <span class="n">sha256_digest</span> <span class="o">=</span> <span class="n">hashlib</span><span class="p">.</span><span class="nf">sha256</span><span class="p">(</span><span class="n">code_verifier_bytes</span><span class="p">).</span><span class="nf">digest</span><span class="p">()</span>
    <span class="n">code_challenge</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="nf">urlsafe_b64encode</span><span class="p">(</span><span class="n">sha256_digest</span><span class="p">).</span><span class="nf">rstrip</span><span class="p">(</span><span class="sa">b</span><span class="sh">'</span><span class="s">=</span><span class="sh">'</span><span class="p">).</span><span class="nf">decode</span><span class="p">(</span><span class="sh">'</span><span class="s">utf-8</span><span class="sh">'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">code_challenge</span>

<span class="c1"># 示例
</span><span class="n">code_verifier</span> <span class="o">=</span> <span class="nf">generate_code_verifier</span><span class="p">()</span>
<span class="n">code_challenge</span> <span class="o">=</span> <span class="nf">generate_code_challenge</span><span class="p">(</span><span class="n">code_verifier</span><span class="p">)</span>

<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">code_verifier:</span><span class="sh">"</span><span class="p">,</span> <span class="n">code_verifier</span><span class="p">)</span>
<span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">code_challenge:</span><span class="sh">"</span><span class="p">,</span> <span class="n">code_challenge</span><span class="p">)</span>
<span class="c1"># code_verifier: 92Foogx4d9Q5cbDbmLrz7eCHfAxX06q-6FHhmyKQ0OMcGpRbu6CWzknxCUSuvJ6b5-D_dIaJB5mHfAIfk_Qu1A
# code_challenge: GFc8vy-W93jTehp7I3Fvzma2DH5JNjnRAoktZuHtywA
</span></code></pre></div></div> <p>所以类似的请求是</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 发起是授权请求</span>
GET /authorize?
  <span class="nv">response_type</span><span class="o">=</span>code&amp;
  <span class="nv">client_id</span><span class="o">=</span>abc123&amp;
  <span class="nv">redirect_uri</span><span class="o">=</span>https://client.example.com/cb&amp;
  <span class="nv">code_challenge</span><span class="o">=</span>E9Melhoa2OwvFrEMTJguCHaoeK1t8URWbuGJSstw-cM&amp;
  <span class="nv">code_challenge_method</span><span class="o">=</span>S256&amp;
  <span class="nv">state</span><span class="o">=</span>xyz

<span class="c"># 换取token</span>
POST /token
Content-Type: application/x-www-form-urlencoded

<span class="nv">grant_type</span><span class="o">=</span>authorization_code&amp;
<span class="nv">code</span><span class="o">=</span>SplxlOBeZQQYbYS6WxSbIA&amp;
<span class="nv">redirect_uri</span><span class="o">=</span>https://client.example.com/cb&amp;
<span class="nv">client_id</span><span class="o">=</span>abc123&amp;
<span class="nv">code_verifier</span><span class="o">=</span>dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
</code></pre></div></div> <h2 id="实操案例">实操案例</h2> <h3 id="github配置oauth-app">GitHub配置OAuth APP</h3> <div class="row mt-3"> <div class="col-sm mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth1-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth1-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="col-sm mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth2-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth2-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth3-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth3-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth4-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth4-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/GitHubOAuth4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/GitHubOAuth4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> </div> <p>按照上面截图方式配置，最后得到对应的Client ID和Client Secret</p> <h3 id="cf-worker部署">CF Worker部署</h3> <p>参考这里https://github.com/cloudflare/ai/tree/main/demos/remote-mcp-github-oauth</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 1. 初始化项目，前两步yes，最后no，因为还没配置也deploy不上去</span>
npm create cloudflare@latest <span class="nt">--</span> mcp-github-oauth <span class="nt">--template</span><span class="o">=</span>cloudflare/ai/demos/remote-mcp-github-oauth
<span class="c"># 2. 安装wrangler</span>
npm <span class="nb">install</span> <span class="nt">-g</span> wrangler
<span class="c"># 3. 配置client id 和 client secret</span>
<span class="nb">cd </span>mcp-github-oauth
wrangler secret put GITHUB_CLIENT_ID
<span class="c"># 输入GitHub Client ID，然后y</span>
wrangler secret put GITHUB_CLIENT_SECRET
<span class="c"># 输入GitHub Client Secret</span>
wrangler secret put COOKIE_ENCRYPTION_KEY
<span class="c"># 输入随机字符串，可以用openssl rand -hex 32</span>
<span class="c"># 4. 设置KV命名空间</span>
wrangler kv:namespace create <span class="s2">"OAUTH_KV"</span>
<span class="c"># 会生成对应的id，拷贝写到wrangler.jsonrc文件里的</span>
	<span class="s2">"kv_namespaces"</span>: <span class="o">[</span>
		<span class="o">{</span>
			<span class="s2">"binding"</span>: <span class="s2">"OAUTH_KV"</span>,
			<span class="s2">"id"</span>: <span class="s2">"abc123"</span>
		<span class="o">}</span>
	<span class="o">]</span>,
<span class="c"># 5. 部署到Wroker，这里会跳到浏览器登录之类的操作，最后选择好用户就可以上传</span>
npm run deploy
</code></pre></div></div> <p>相关操作截图如下</p> <div class="row mt-3"> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth1-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth1-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth1-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth2-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth2-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth2-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth3-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth3-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth3-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth4-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth4-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth4-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> </div> <h3 id="测试">测试</h3> <p>现在支持MCP认证的客户端比较少，cursor目前也没计划支持，我们用官方的inspector来测试</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npx @modelcontextprotocol/inspector@latest
</code></pre></div></div> <p>通过SSE来连接，比如 https://mcp-github-oauth.ifuryst.workers.dev/sse</p> <p>大体流程是：连接后因为没有认证授权所以会返回401，这个时候MCP Client会根据MCP Servers暴露的Server Metadata Discovery（在https://mcp-github-oauth.ifuryst.workers.dev/.well-known/oauth-authorization-server）去发现认证的信息，然后跳转到对应的地址去做认证。这里会先到CF Worker上部署的这个服务的页面，然后点击确认后会跳到GitHub做实际的认证，最后跳回MCP Client的callback接口，通常是/oauth/callback，比如Inspector这里是http://127.0.0.1:6274/oauth/callback</p> <div class="row mt-3"> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth5-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth5-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth5-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth6-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth6-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth6-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth6.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth7-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth7-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth7-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth8-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth8-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth8-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth9-480.webp 480w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth9-800.webp 800w,/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth9-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2025-05-12-mcp-authorization/MCPGitHubOAuth9.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> </div> <p>在浏览器整个流程相对丝滑，如果是客户端的MCP Client，通常是跳转浏览器做登录或者应用内打开外部网页做登录，这里涉及到应用本身也需要监听，因为需要对callback做处理</p> <h2 id="结论">结论</h2> <p>MCP是个年轻的协议，提出大半年，鉴权方案也是3月份新的修订才有的，这里其实存在一定的争议，有人认为这不是最佳实践，我们可以看<a href="https://github.com/modelcontextprotocol/modelcontextprotocol/issues/205">这里的讨论</a>。也就是现在其实更多是把MCP Server当作OAuth授权服务器，这样对于MCP Server的提供者是一个负担，大部分MCP Server更偏向于一个轻量的或者微服务形态的，还需要他们去集成对应的鉴权，无疑是巨大的Effort。</p> <p>基于这个，目前MCP Gateway正在开发面向端侧的鉴权体系，这样可以让MCP Gateway适应更多的场景，各类服务也可以接入MCP Gateway快速适配认证场景。</p> <p>如果你感兴趣我的开源项目，欢迎使用、反馈和任何的贡献参与</p> <p>https://github.com/mcp-ecosystem/mcp-gateway</p>]]></content><author><name></name></author><category term="AI"/><category term="AI"/><summary type="html"><![CDATA[官方新的修订版本支持了OAuth2的鉴权方式，我们一起来看看]]></summary></entry><entry><title type="html">MCP之于HTTP</title><link href="https://ifuryst.github.io/blog/2025/mcp-vs-http/" rel="alternate" type="text/html" title="MCP之于HTTP"/><published>2025-05-08T05:30:00+00:00</published><updated>2025-05-08T05:30:00+00:00</updated><id>https://ifuryst.github.io/blog/2025/mcp-vs-http</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/mcp-vs-http/"><![CDATA[<p>MCP可以类比HTTP之于Web时代的意义，或许MCP是AI时代的一个常用协议之一</p> <p>过去一个月，行业动作频频：</p> <ul> <li>OpenAI和Amazon前两周都声明他们会采用MCP标准</li> <li>Google CEO上个月也在X上说会考虑采用MCP标准</li> </ul> <p>MCP 会成为 AI 时代的HTTP吗？</p> <p>我觉得现在下这个结论太早了，更多是自媒体或者相关从业者自嗨的标题。但是我们依然无法阻挡MCP被大量adopt的趋势，过去2个月得益于各种媒体的传播，MCP的风刮到了技术和非技术人的视野里。</p> <p>在这样的趋势之下，我也开始了自己的探索，这一直是我在做的事情，我发现已经很多人做起了MCP应用市场的行当了，包括一些诸如Cline之类的MCP Client自己也在做，类似App Store帮助大家更方便的搜索安装MCP Server。在目前这个阶段似乎大家的关注点都在重MCP Client的方向，包括Anthropic一开始制订的stdio（大量的MCP Server走了这个）和SSE来看也是偏Client的。非常能理解，端侧的应用是一个极大的应用场景，加上现在大家深耕Agentic AI，等于AI帮你代理了在终端的各类操作，终端也有你平时使用的各类环境，非常方便直接无缝集成，所以我认为这个趋势没有问题</p> <p>在大家还没有投入重视的远端、云端和服务端场景，未来也会大量爆发应用，可想而知上面的重端侧场景并不适应企业或者更加专业的玩家，MCP的应用也不只是针对端侧，在服务端，企业内部，企业对外的服务都会大量的应用，我觉得原来的FunctionCalling都会陆续转MCP，另外一点就是很多存量的API服务需要改造MCP，我觉得这个过程必然衍生出一些助力这个过程的软件或服务</p> <p>基于这个背景，MCP Gateway就诞生了，上个月中我开源了这个项目，几个目的和愿景：</p> <ol> <li>旨在通过配置的方式将存量API转成MCP Servers，完全无需任何改造</li> <li>代理MCP Servers，比如stdio、SSE和Streamable HTTP的协议互转</li> <li>统一网关分发，大胆的类比MCP领域的Nginx</li> <li>延伸的MCP服务治理，MCP想象空间足够大，可想如果几十上百的MCP接入，该如何治理呢？</li> <li>企业级的性能、稳定性、高可用和扩展性</li> </ol> <p>还有一周这个项目满1个月，我已经完成了160个Commits，迭代了13个版本，并且收获到了600+的🌟，对于大家的反馈，让我感受到这个项目的潜力和应用的前景。目前我还在持续迭代，欢迎大家使用和反馈。在这里也欢迎有想法的朋友一起共建❤️</p>]]></content><author><name></name></author><category term="AI"/><category term="AI"/><summary type="html"><![CDATA[MCP可以类比HTTP之于Web时代的意义，或许MCP是AI时代的一个常用协议之一]]></summary></entry><entry><title type="html">【Iter-X】 79/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-79-100/" rel="alternate" type="text/html" title="【Iter-X】 79/100days"/><published>2025-05-06T15:59:59+00:00</published><updated>2025-05-06T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-79-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-79-100/"><![CDATA[<p>Day7️⃣9️⃣</p> <p>仔细思考了一下，我决定还是停止继续这个Build in Public 100 Days的系列，几个原因：</p> <p>1️⃣ 一个是因为到后面观看的人数越来越少，我觉得流水账本身就不足以吸引人</p> <p>2️⃣ Iter-X的优先级被我降低了，目前另外两个项目的推进速度和收益更加充足</p> <p>3️⃣ 我希望用独立文章的形式来发表内容，目前其实我的标题是固定的，但是我经常会产出一些不错的内容，似乎被标题或者整个系列影响了，更难触及到受众</p> <p>综合这些原因，我考虑暂停此次这个系列。总体而言这次我收获到很多，79天，如同过山车一样，也结实了不少的朋友。也进一步夯实我的书写能力，我有信心能写出更多好的文章。对于还关注我的朋友，可以到GitHub和我的Blog里follow我的动态，后续我会收敛一下，不会把这些内容过多的抛到社交媒体上，社交媒体上我还是会继续做一些旅游相关的内容，开发、产品和创业相关的，还有一些思想和见闻我都会集中收录在我的blog里，社交媒体的书写长度天然限制表达，我不想要在表达这方面做妥协。我会在个人的思考，个人创作创业，前沿AI和Tech见闻，商业世界的见解等方面去发表内容，如果你感兴趣，欢迎follow</p> <p>山高路远，我会持续活跃的，我不是很优秀的人，也不是很聪明很厉害的人，但是我相信我是很坚持很有行动力的那一批人，我会持续把自己的想法付诸行动，不论成败，不唯结果论。</p>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣9️⃣]]></summary></entry><entry><title type="html">【Iter-X】 78/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-78-100/" rel="alternate" type="text/html" title="【Iter-X】 78/100days"/><published>2025-05-05T15:59:59+00:00</published><updated>2025-05-05T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-78-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-78-100/"><![CDATA[<p>Day7️⃣8️⃣</p> <p>这次出行收获很大，不仅仅是放松休息了一波，还有很多额外的收获，这个也是旅行的一部分一样，不过这次不算是一个常规的旅行，因为还有很多非旅行的东西在里面。这次确实经历了很多东西，昨晚其实是在喝了酒之后写的东西，看了一下还没喝醉，哈哈。</p> <p>这次出行也意外了获得了一些生意上的机会，我觉得是个不错的机会，算是对于这一两年来在AI方面的沉淀的一个正向反馈，我觉得AI在应用层和不同的行业的渗透才在初期阶段，后续会有更多这种机会不断浮现，头部玩家有其玩法，中小玩家也有另一套的玩法，toCtoBtoG都有不同的玩法，我觉得能把资金、技术、渠道、商务和市场结合在一起的人或团队，有机会在这次浪潮中抢滩。如同互联网浪潮，泡沫很大，但是也释放出足够多的机会，也有很长的长尾效应持续让各种传统行业进行互联网化。AI时代同样也有泡沫，也可能破掉，但是不可否认这其中多大的市场空间可以去有作为。</p> <p>虽然我写的东西基本上是一个小范围的技术人看到的，但是我仍然开放心态面对非技术人员，如果你是在某个行业想要借助AI去搞一些事情的话，欢迎你找我聊聊，不管是简单的咨询还是存在进一步合作的可能性，1+1一定大于2，很容易有双赢的局面的</p>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣8️⃣]]></summary></entry><entry><title type="html">【Iter-X】 77/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-77-100/" rel="alternate" type="text/html" title="【Iter-X】 77/100days"/><published>2025-05-04T15:59:59+00:00</published><updated>2025-05-04T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-77-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-77-100/"><![CDATA[<p>Day7️⃣7️⃣</p> <p>充实的一天，从早上到晚上，几乎没怎么停过，去了好几个地方，见了很多人，感受了生死，也聊了人生的起落。人生几十年，很快就过了，在面对死亡，我们可以更好的思考自己想要如何过完这一生，对于人生起落的思考，也加深了对于人生重要节点所带来的一系列因果的理解。世俗的成功是我们一直在追求的，但是除此之外，或许有一些更深次的东西值得我们追求，很多时候前者的优先级高于后者。现在是能看到很多新世代可以用精神满足对抗物质的不足，是一个很好的迹象，我觉得可以理解为一种精神层次的进步，不过大多数人还是逃不过这个固有的模式。</p> <p>明晚回归，一切会陆续回归正轨，继续持续输出。No pain, no gain — and I’m not done yet.✊</p>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣7️⃣]]></summary></entry><entry><title type="html">【Iter-X】 76/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-76-100/" rel="alternate" type="text/html" title="【Iter-X】 76/100days"/><published>2025-05-03T15:59:59+00:00</published><updated>2025-05-03T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-76-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-76-100/"><![CDATA[<p>Day7️⃣6️⃣</p> <p>每次出门旅行或者大量现充的生活节奏下，和平时不断Build各种东西的节奏都不太一样，整个人的想法都有明显的不同。</p> <p>平时更多是关注在个人的积累，持续的输出，项目和产品的方向进度等等东西。现充的场合下会充斥大量的社交，会让你没有空去思考处理那些东西，大量的时间被释放到社交层面，旅行的时候则是大量时间精力投入到去经历去感受新的事物，产生新的经历和想法。</p> <p>就我个人而言，我觉得这三种模式都是不可获取的，只是占比有所不同，如何取舍如何平衡就能映射出个人的追求方向了，虽然社交需要投入很多时间精力，成年人的世界追求的更多是“有效社交”，但我还挺喜欢偶尔的随心社交，似乎能带来一种特别的视野，对冲掉了长期专注于个人事业或商业化成功这类事情的一个固化心态，更像是一种打破，所以对我而言是一种补偿机制。旅行也是，我喜欢旅行不仅仅是可以给我带来对于不同事物的感受，也就是增加视野，我也喜欢旅行过程中可以有的一种不同场地之下可以进行不同程度和角度的思考，不见得是很深刻的，但是可以是很新奇很有趣的。</p> <p>这两天的日记更像是日记了，开始写起了自己的经历和想法，对于项目或产品上的输出变少了，感觉这个Build In Public的系列和前面的节奏不太一样了，哈哈。Keep It Real. 不管Day 100的时候如何，我觉得都是一个很好的过程和经历，我希望后续自己能持续输出，这是一个正向循环，目前写作能力和速度都得到了比较明显的提升，我需要能快速的把想法落下来分享出来，对于信息的摄入和成果的转化输出非常有帮助。不过目前IterX的进度或许让一些持续关注的朋友失望了，这块等我51回去后会再来盘一下</p> <p>汇总目前情况：</p> <ol> <li>原型设计&amp;UI/UX设计：33%</li> <li>后端（Go）开发：60%</li> <li>客户端（flutter）进度：58%</li> <li>数据：14%</li> </ol> <p>如果你认为你符合以下条件，欢迎来聊：</p> <ol> <li>能坚持</li> <li>有梦想</li> <li>有兴趣</li> </ol>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣6️⃣]]></summary></entry><entry><title type="html">【Iter-X】 75/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-75-100/" rel="alternate" type="text/html" title="【Iter-X】 75/100days"/><published>2025-05-02T15:59:59+00:00</published><updated>2025-05-02T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-75-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-75-100/"><![CDATA[<p>Day7️⃣5️⃣</p> <p>忙碌的一天，早起早班机开启忙碌的一天，现在才有点空档休息一下。今年这个51出行的人数绝对空前，从全天客机满座率和酒店的价格和空闲的情况可见一斑，一天酒店的价格持续飙升，陆续变成满房的状态，比前面几年的势头更加猛。这里也能看得出国内旅游行业的持续增量，不禁思考，这样的趋势会持续多久？因为就市场规律而言，若长期处于这种假期出行人挤人，出行看人的节奏，那按照市场供需情况来说，这个似乎很难一直持续，但是对于纵观全年假期本身就不多的普遍情况来看，若是节假日不选择出行的话，那合适才能出去看看呢？这是一个矛盾的关系：节假日出行需要承担更大的成本的情况之下，得到的“服务”或者旅行质量不足的情况下，消费者会如何选择呢？</p> <p>我们试着分析一下可能的解决方案：</p> <p>1️⃣ 开发更多的景点，进行有效的分流，这个也是很多地方在做的，但是因为景点开发存在周期较长的情况，所以并不是一件容易的事情。不过目前有一些点可以通过社交媒体轻易撬动巨大的流量，但是配套服务需要能持续跟上才能做到可持续发展</p> <p>2️⃣ 个性化定制的行程。当旅行的目的地或者经历足够的情况下，人们会开始追求差异化的感受，但是对于某些地方的有差异化有特色的行程是需要一些了解情况的人去深耕的，也就是相关行业的从业者进行发掘并提供对应的服务，我觉得这个也是目前国内一些企业在开拓的市场。不过这个目前会更加偏向于中高端旅行，毕竟有利润空间服务才能更得上，这块也在持续增量</p> <p>3️⃣ 分流国外，但是这个从国家的角度来看，不一定会期望大家分流到国外，因为消费力外流，不利于有效促进消费这辆大车。但是对于个人和企业是“有利可图”的，他能在价格相对美丽的情况之下提供足够大的差异化体验，在某种程度上对于消费者和服务提供方都是双赢的一个场景</p> <p>4️⃣ 算是第1点的延伸，城市游或周边游开拓，可以将一部分游客继续留在所在地，比如近年来不断涌现的结合农家乐的亲子互动的点，是可以一定程度抑制人群在节假日大量迁徙流动，并且在平时的周末也可以持续深耕创造更多的本地消费</p> <p>理论上在全球经济持续不振的背景之下，旅游行业很难持续增长，但是在疫情多年的压抑之下，目前我觉得算是持续反弹的阶段，尤其是新世代对于个人感受的变化，更加看重个人体验，更愿意支付大量的时间精力成本去完成一段体验。</p> <p>汇总目前情况：</p> <ol> <li>原型设计&amp;UI/UX设计：33%</li> <li>后端（Go）开发：60%</li> <li>客户端（flutter）进度：58%</li> <li>数据：14%</li> </ol> <p>如果你认为你符合以下条件，欢迎来聊：</p> <ol> <li>能坚持</li> <li>有梦想</li> <li>有兴趣</li> </ol>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣5️⃣]]></summary></entry><entry><title type="html">【Iter-X】 74/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-74-100/" rel="alternate" type="text/html" title="【Iter-X】 74/100days"/><published>2025-05-01T15:59:59+00:00</published><updated>2025-05-01T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-74-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-74-100/"><![CDATA[<p>Day7️⃣4️⃣</p> <p>假期第一天还是在家里，哈哈，今天出去见识了一下游客的数量，简直人头攒动啊。又着手release了2个版本，高效输出。</p> <p>今天出去逛的时候又Get了一个Idea，想做一个保险通，目前因为一些原因，国人对于保险的认知和认可程度都较低，原因有好几个，我觉得其中有一个是对于业务的抵抗，以及对晦涩难懂的保险条款头疼，包括对于保险本身的信息差导致认知差异，包括今天我们其实就遇到了一个70岁的老人是否可以购买重疾险的问题还特意去看了对应的保险产品，我就觉得是可以收集主流的保险公司的保险产品的条款等信息，然后通过AI+RAG去做一个数字保险顾问，可以针对需求去快速定位到适合购买的保险，在这期间可以结合AI对保险的各种名词作解释，起到教育市场的作用。因为据我了解，大部分业务员本身的素质水平其实都不高，虽然现在保险队伍开始提高业务员的教育背景水平，但是仍然参差不齐。我觉得这个产品本身就可以走免费的，最后对接保险公司，如果用户能在这里进行下单，我们可以从B端获得一定的费用。我觉得这是一个很好的可商业化的机会，我没有做过市场调研，我不确定目前市场是否有竞品存在（大概率是有，并且有好几款），不过我仍然看好这个Idea。如果我决定开始做的话，我可能会考虑先Build一个针对自己和身边朋友使用的版本，然后在适当的社群里推广，此阶段完全没有任何商业进入，从用户角度出发，我觉得是有可能积累一定的用户基础的。</p> <p>不知道大家有没有用过那种看报告的AI医生，我觉得非常好，因为现实中很多医生都没办法没那个条件给你详细解释你的病情，结合你的背景情况分析并给出合理的合适的建议，所以很多人会久病成医。我觉得AI医生是一个非常棒的东西，排除可能诊断出错的问题下会偏保守的给意见，但是在客观教学和个性化诊断建议上是对患者非常好的一个手段，比如我们听到一个全新的病，我们可以一步步去咨询，最终了解这个病的发病机制，自己的生活方式和习惯里哪里有可能会导致这个问题，可以针对性的去思考对策，我觉得前面的保险通或者其他垂直领域的应用都是有非常的前景和想象空间。</p> <p>当然一个好的产品就是在不断的去除那些不好用的地方，但是从创造者或者创业者的角度来说，我们应该做的是首先抓住并认可那些好用的点，然后用自身的能力和资源去扩大那个好用的点，尽最大可能把不好用的点处理掉，那成功可能不远了。所以这是两个思维上的差异，也是我最经常看到的两类人，不知道你是哪类人呢？我觉得也没有什么客观好坏之分的界定，更多的是适不适合在这条路上走的差别。</p> <p>汇总目前情况：</p> <ol> <li>原型设计&amp;UI/UX设计：33%</li> <li>后端（Go）开发：60%</li> <li>客户端（flutter）进度：58%</li> <li>数据：14%</li> </ol> <p>如果你认为你符合以下条件，欢迎来聊：</p> <ol> <li>能坚持</li> <li>有梦想</li> <li>有兴趣</li> </ol>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣4️⃣]]></summary></entry><entry><title type="html">【Iter-X】 73/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-73-100/" rel="alternate" type="text/html" title="【Iter-X】 73/100days"/><published>2025-04-30T15:59:59+00:00</published><updated>2025-04-30T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-73-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-73-100/"><![CDATA[<p>Day7️⃣3️⃣</p> <p>开始假期模式了，开源项目截止目前571个Star了，到今天刚好15天，也开始陆续有人接入使用和反馈了，这个速度我挺满意的，我暂时给下一阶段定的一个milestone是1k stars的时候我会着手开始发布Cloud Version，让一些人可以直接在页面上配置就可以体验了，这个阶段基本都会是免费的使用的，再下一阶段就是分化出一个商业版本，不过目前我还没考虑到这么远，那个等1k stars达成后再来思考吧。商业版是我对于这个项目盈利模式的思考，到时候会有一些特性分叉到商业版里，这是一个平衡，你需要平衡好开源和商业版本的这个特性分布，太多放在开源版本会让商业版没有什么吸引力，太少放在开源版本又会影响别人去采用和对你进行共享的推进速度，减少社区活力。</p> <p>这个案例就是一个非常好的案例：</p> <ol> <li>保持对一些市场空白保持敏锐的嗅觉</li> <li>说干就干，几天时间快速迭代一个MVP出来</li> <li>小范围内在一些潜在受众的社区去推出去，得到反馈</li> <li>得到反馈后持续快速迭代</li> </ol> <p>是一个健康AI时代的产品或者项目迭代的节奏。反观Iter-X，我认为还是太慢了，不过toC本身打法还是不太一样，是需要有一些最低底线的要求和保障。只不过这次的经历还是让我学习到很多东西啊，我觉得PartTime的协作者和FullTime的协作者的玩法又差别蛮大的，想在FullTime里找到靠谱的合伙人就是一件巨难的事情，在此基础上还想在PartTime的池子里找到同行人更加困难，这样分析一下还是很合理的，这个Build in Public还真的是一件不错的事情，逼迫自己去复盘去思考汇总，我相信等100天走完，哪怕0Day我想要Launch的产品最终没有Launch，我也经历并学到了很多。</p> <p>顺带一提，这两天我有一个新的Idea正在逐步成型（营收模型非常的明确，也经过市场验证了），目前我正在积极的做可行性调查，这次我可能会选择solopreneur的方式来推进，等我这两天假期模式刚好可以处理一下这个，目前还是不打算分享，不过如果你是在AI应用层方面有很强的理解和实践能力，欢迎你找我聊，如果这个Idea验证完并且有成功跑出来的话，需要在AI应用层做持续的深耕。</p> <p>汇总目前情况：</p> <ol> <li>原型设计&amp;UI/UX设计：33%</li> <li>后端（Go）开发：60%</li> <li>客户端（flutter）进度：58%</li> <li>数据：14%</li> </ol> <p>如果你认为你符合以下条件，欢迎来聊：</p> <ol> <li>能坚持</li> <li>有梦想</li> <li>有兴趣</li> </ol>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣3️⃣]]></summary></entry><entry><title type="html">【Iter-X】 72/100days</title><link href="https://ifuryst.github.io/blog/2025/iter-x-72-100/" rel="alternate" type="text/html" title="【Iter-X】 72/100days"/><published>2025-04-29T15:59:59+00:00</published><updated>2025-04-29T15:59:59+00:00</updated><id>https://ifuryst.github.io/blog/2025/iter-x-72-100</id><content type="html" xml:base="https://ifuryst.github.io/blog/2025/iter-x-72-100/"><![CDATA[<p>Day7️⃣2️⃣</p> <p>马上节假日了，要出门走走了，春节从美国回来到现在，差不多3个月，都在高强度的输出，出门吃喝玩乐一下，72天前我选择开始做这个旅行APP的原因也是因为自己喜欢旅行，不忘初心。不过我很不喜欢出去看人，人挤人，一点体验也没有，这也是为什么我尤其喜欢去国外旅行的原因，我觉得很多人有条件去国外旅行，但是从总体的比例来看，只有比较少的一部分真的去了，并持续去。</p> <p>我会把这个APP打造成记录生活经历的一个载体，现在其实更多是记录在笔记、照片、视频、pyq、社交媒体和脑子里。不过反过来想想，不知道大家对于回忆是持什么态度呢？有人会经常回忆美好，有些人基本持续向前看，也有人两者之间，我算是两者之间，我比较少去翻看以前的照片视频，更多是看到一些相关联的东西回忆其某个记忆片段，我觉得整理照片和旅行相关的东西是一个Effort很大的东西，AI可以解决很大一部分痛点。</p> <p>汇总目前情况：</p> <ol> <li>原型设计&amp;UI/UX设计：33%</li> <li>后端（Go）开发：60%</li> <li>客户端（flutter）进度：58%</li> <li>数据：14%</li> </ol> <p>如果你认为你符合以下条件，欢迎来聊：</p> <ol> <li>能坚持</li> <li>有梦想</li> <li>有兴趣</li> </ol>]]></content><author><name></name></author><category term="products"/><category term="products"/><summary type="html"><![CDATA[Day7️⃣2️⃣]]></summary></entry></feed>
<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ifuryst.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ifuryst.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-10-27T13:57:05+00:00</updated><id>https://ifuryst.github.io/feed.xml</id><title type="html">ifuryst</title><subtitle>📝 &amp; 💭 </subtitle><entry><title type="html">Go语言基于benchstat做基准测试与性能跟踪</title><link href="https://ifuryst.github.io/blog/2024/benchmarking-n-performance-tracking-in-go-using-benchstat/" rel="alternate" type="text/html" title="Go语言基于benchstat做基准测试与性能跟踪"/><published>2024-10-27T12:56:27+00:00</published><updated>2024-10-27T12:56:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/benchmarking-n-performance-tracking-in-go-using-benchstat</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/benchmarking-n-performance-tracking-in-go-using-benchstat/"><![CDATA[<h1 id="benchmark">Benchmark</h1> <p>在开发过程中，我们会做一些基准测试（Benchmark），用于去评估一些函数之间的性能差异，比如常规情况我们可能会这样做：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">slice</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"sort"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">SortedIncludes</span><span class="p">(</span><span class="n">strArray</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">target</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">sort</span><span class="o">.</span><span class="n">Strings</span><span class="p">(</span><span class="n">strArray</span><span class="p">)</span>
	<span class="n">index</span> <span class="o">:=</span> <span class="n">sort</span><span class="o">.</span><span class="n">SearchStrings</span><span class="p">(</span><span class="n">strArray</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">strArray</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Contains</span><span class="p">[</span><span class="n">T</span> <span class="n">comparable</span><span class="p">](</span><span class="n">list</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">ele</span> <span class="n">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">list</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">ele</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkSortedIncludes</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">SortedIncludes</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkContains</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">Contains</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>我们跑测之后的结果如下：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># go test -bench=. -benchmem ./slice/slice_including_test.go</span>
goos: darwin
goarch: arm64
cpu: Apple M3 Pro
BenchmarkSortedIncludes-12      60017379                21.56 ns/op            0 B/op          0 allocs/op
BenchmarkContains-12            653826099                1.877 ns/op           0 B/op          0 allocs/op
PASS
ok      command-line-arguments  3.856s
</code></pre></div></div> <p>这种情况下我们是可以直接根据基准测试的结果很明确的知道<code class="language-plaintext highlighter-rouge">Contains</code>的效率是更好的。</p> <p>但是在实际的实践中，上面这种方式只适合我们在开发的时候对比测试最后选用的这样一个情况，之后这个基准测试对我们几乎是没有用处了，我们也很难持续跟踪某个函数的性能变化情况。基于这个问题，benchstat在某种程度上是可以帮我们解决这个问题。</p> <h1 id="benchstat">Benchstat</h1> <p><a href="https://github.com/iFurySt/go-benchstat-demo">https://github.com/iFurySt/go-benchstat-demo</a></p> <p>这一节相关的代码和命令我都整理在这个repo里了</p> <blockquote> <p>Benchstat computes statistical summaries and A/B comparisons of Go benchmarks.</p> </blockquote> <p>简而言之，benchstat就是用来做基准测试对比的，可以是一次改动的前后对比，也可以是和历史的某次对比。这样其实是可以持续跟踪性能变化的</p> <p>这里我们模拟了一个业务调用一个函数的逻辑：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"github.com/ifuryst/go-benchstat-demo/pkg/util"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">mockBiz</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">mockBiz</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ss</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">}</span>
	<span class="n">s1</span> <span class="o">:=</span> <span class="s">"a"</span>
	<span class="n">isInclude</span> <span class="o">:=</span> <span class="n">util</span><span class="o">.</span><span class="n">Includes</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Is %s in %v? %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">isInclude</span><span class="p">)</span>
	<span class="n">s2</span> <span class="o">:=</span> <span class="s">"d"</span>
	<span class="n">isInclude</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">Includes</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Is %s in %v? %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">isInclude</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div> <p>相关的函数：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">util</span>

<span class="k">import</span> <span class="s">"sort"</span>

<span class="k">func</span> <span class="n">Includes</span><span class="p">(</span><span class="n">ss</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">sort</span><span class="o">.</span><span class="n">Strings</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
	<span class="n">index</span> <span class="o">:=</span> <span class="n">sort</span><span class="o">.</span><span class="n">SearchStrings</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ss</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>
</code></pre></div></div> <p>就是一个简单的在列表里查找某个值是否存在，上面这个是v1.0.0的版本，到v2.0.0了这个方法被改进了</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">util</span>

<span class="k">import</span> <span class="s">"testing"</span>

<span class="k">func</span> <span class="n">BenchmarkInclude</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">Includes</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这种情况其实我们可能不知道性能整体是怎样变化的，因此我们分别对biz和Include增加一下benchmark</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"os"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">BenchmarkBiz</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">old</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">devNull</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">DevNull</span><span class="p">)</span>
	<span class="k">defer</span> <span class="n">devNull</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
	<span class="n">os</span><span class="o">.</span><span class="n">Stdout</span> <span class="o">=</span> <span class="n">devNull</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span> <span class="o">=</span> <span class="n">old</span> <span class="p">}()</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">mockBiz</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>以及</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">util</span>

<span class="k">import</span> <span class="s">"testing"</span>

<span class="k">func</span> <span class="n">BenchmarkInclude</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">Includes</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这个时候我们是可以通过go test做基准测试的，这个时候我们可以在两个版本分别做一下</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout v1.0.0
go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span><span class="nb">.</span> <span class="nt">-benchmem</span> <span class="nt">-count</span><span class="o">=</span>10 ./... <span class="o">&gt;</span> old-<span class="sb">`</span>git rev-parse HEAD<span class="sb">`</span>.txt
git checkout v2.0.0
go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span><span class="nb">.</span> <span class="nt">-benchmem</span> <span class="nt">-count</span><span class="o">=</span>10 ./... <span class="o">&gt;</span> new-<span class="sb">`</span>git rev-parse HEAD<span class="sb">`</span>.txt
</code></pre></div></div> <p>这个命令就是做benchmark，同时也统计内存的情况，跑10次基准测试是为了减少一些误差，将结果分别输出到两个文件，然后我们就可以用benchstat对比这两个文件</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>benchstat old-<span class="k">*</span>.txt new-<span class="k">*</span>.txt
</code></pre></div></div> <p>输出结果如下：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goos: darwin
goarch: arm64
pkg: github.com/ifuryst/go-benchstat-demo
cpu: Apple M3 Pro
       │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
       │                      sec/op                      │          sec/op            vs base               │
Biz-12                                        914.4n ± 2%                 881.4n ± 4%  <span class="nt">-3</span>.61% <span class="o">(</span><span class="nv">p</span><span class="o">=</span>0.007 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span>

       │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
       │                       B/op                       │             B/op              vs base            │
Biz-12                                         320.0 ± 0%                     320.0 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

       │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
       │                    allocs/op                     │          allocs/op            vs base            │
Biz-12                                         13.00 ± 0%                     13.00 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

pkg: github.com/ifuryst/go-benchstat-demo/pkg/util
           │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
           │                      sec/op                      │          sec/op           vs base                │
Include-12                                       20.095n ± 2%                1.881n ± 1%  <span class="nt">-90</span>.64% <span class="o">(</span><span class="nv">p</span><span class="o">=</span>0.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span>

           │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
           │                       B/op                       │             B/op              vs base            │
Include-12                                         0.000 ± 0%                     0.000 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

           │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
           │                    allocs/op                     │          allocs/op            vs base            │
Include-12                                         0.000 ± 0%                     0.000 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

</code></pre></div></div> <p>让ChatGPT🤖帮我们组织美化成表格可能更好看：</p> <p>Package: <code class="language-plaintext highlighter-rouge">github.com/ifuryst/go-benchstat-demo</code></p> <p>CPU: Apple M3 Pro (<code class="language-plaintext highlighter-rouge">goos: darwin</code>, <code class="language-plaintext highlighter-rouge">goarch: arm64</code>)</p> <table> <thead> <tr> <th>Test</th> <th>Metric</th> <th>Old (sec/op)</th> <th>New (sec/op)</th> <th>Change</th> <th>P-Value</th> <th>Samples</th> </tr> </thead> <tbody> <tr> <td>Biz-12</td> <td>sec/op</td> <td>914.4n ± 2%</td> <td>881.4n ± 4%</td> <td>-3.61%</td> <td>p=0.007</td> <td>n=10</td> </tr> <tr> <td>Biz-12</td> <td>B/op</td> <td>320.0 ± 0%</td> <td>320.0 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> <tr> <td>Biz-12</td> <td>allocs/op</td> <td>13.00 ± 0%</td> <td>13.00 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> </tbody> </table> <p>Package: <code class="language-plaintext highlighter-rouge">github.com/ifuryst/go-benchstat-demo/pkg/util</code></p> <table> <thead> <tr> <th>Test</th> <th>Metric</th> <th>Old (sec/op)</th> <th>New (sec/op)</th> <th>Change</th> <th>P-Value</th> <th>Samples</th> </tr> </thead> <tbody> <tr> <td>Include-12</td> <td>sec/op</td> <td>20.095n ± 2%</td> <td>1.881n ± 1%</td> <td>-90.64%</td> <td>p=0.000</td> <td>n=10</td> </tr> <tr> <td>Include-12</td> <td>B/op</td> <td>0.000 ± 0%</td> <td>0.000 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> <tr> <td>Include-12</td> <td>allocs/op</td> <td>0.000 ± 0%</td> <td>0.000 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> </tbody> </table> <p>解释一下这几个列的含义：</p> <ul> <li>Test：对应的基准测试的名称</li> <li>Metric：测量的指标： <ul> <li>sec/op：每个操作花费的秒数，用来衡量函数执行一个操作所需的时间，越低越好。</li> <li>B/op：每个操作分配的字节数，用来衡量函数执行时内存分配的大小，越少越好。</li> <li>allocs/op: 每个操作的内存分配次数，用来衡量函数执行时发生了多少次内存分配，越少越好。</li> </ul> </li> <li>Old (sec/op)：旧版本的基准测试结果平均花费时间和误差范围</li> <li>New (sec/op):：新版本的基准测试结果</li> <li>Change：新旧版本性能的变化百分比，负值表示性能提升</li> <li>P-Value：统计学中的P值，用来衡量结果的显著性，一般来说小于0.05就是效果显著，1就是差异不明显</li> <li>Samples：基准测试的样本数量，表示每个基准测试的运行次数</li> </ul> <p>我们可以很直观的从表格里看出，v2的时候Include的执行时间提升了90%，但是我们同时可以看到对于Biz来说整体其实是没怎么提升的，这里应该是打印日志把整体的性能都拉低了，导致压不出来</p> <p>有了benchstat，我们其实是可以在CI环节就可以针对PR对比前后的性能变化，也可以按照发布的版本在每次发版前跟踪版本间的性能差异</p> <h1 id="references">References</h1> <ul> <li><a href="https://pkg.go.dev/golang.org/x/perf/cmd/benchstat">https://pkg.go.dev/golang.org/x/perf/cmd/benchstat</a></li> <li><a href="https://github.com/iFurySt/go-benchstat-demo">https://github.com/iFurySt/go-benchstat-demo</a></li> </ul>]]></content><author><name></name></author><category term="Coding"/><category term="Go"/><summary type="html"><![CDATA[Benchmark]]></summary></entry><entry><title type="html">MacOS Sequoia 15.0.1 Option热键绑定失效问题</title><link href="https://ifuryst.github.io/blog/2024/resolving-option-key-hotkey-issues-in-macos-sequoia/" rel="alternate" type="text/html" title="MacOS Sequoia 15.0.1 Option热键绑定失效问题"/><published>2024-10-17T14:00:27+00:00</published><updated>2024-10-17T14:00:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/resolving-option-key-hotkey-issues-in-macos-sequoia</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/resolving-option-key-hotkey-issues-in-macos-sequoia/"><![CDATA[<h1 id="背景">背景</h1> <p>问题是15.0.1禁用<code class="language-plaintext highlighter-rouge">Option+*</code>或者<code class="language-plaintext highlighter-rouge">Option+Shift+*</code>热键绑定，相关讨论看这里</p> <p><a href="https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/">https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/</a></p> <p>官方对此的说法是：<a href="https://developer.apple.com/forums/thread/763878?answerId=804374022#804374022">这是一个有意为之的改变</a></p> <h1 id="方案-hammerspoon">方案: Hammerspoon</h1> <p>相信很多人都会用<code class="language-plaintext highlighter-rouge">Option</code>来绑定自定义的热键，因为<code class="language-plaintext highlighter-rouge">Command</code>和<code class="language-plaintext highlighter-rouge">Control</code>键已经被大量场景占用了。我也是以前经常会使用<code class="language-plaintext highlighter-rouge">Option+*</code> 来快速切换应用的焦点，比如C代表Chrome，S代表Sublime Text，现在不能用了略难受，发现了一个方式可以实现，就是用<code class="language-plaintext highlighter-rouge">Hammerspoon</code> （Reddit里<a href="https://www.reddit.com/r/macapps/comments/1fjpiiw/comment/lolslnm/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">danrnx</a>的回复给了我灵感）</p> <p><a href="https://github.com/Hammerspoon/hammerspoon">https://github.com/Hammerspoon/hammerspoon</a></p> <h2 id="安装">安装</h2> <p>具体方式如下</p> <ol> <li>安装应用，Release里下载或者brew安装</li> <li>配置，写lua，保存到<code class="language-plaintext highlighter-rouge">~/.hammerspoon/init.lua</code></li> </ol> <p>可以参考官方的<a href="https://www.hammerspoon.org/go/">指导</a></p> <h2 id="示例">示例</h2> <h3 id="示例1-不是焦点时获取应用焦点并打印文字">示例1: 不是焦点时获取应用焦点并打印文字</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hs.hotkey.bind<span class="o">({</span><span class="s2">"alt"</span><span class="o">}</span>, <span class="s2">"C"</span>, <span class="k">function</span><span class="o">()</span>
  <span class="nb">local </span>currentApp <span class="o">=</span> hs.application.frontmostApplication<span class="o">()</span>

  <span class="k">if </span>currentApp:name<span class="o">()</span> <span class="o">==</span> <span class="s2">"Google Chrome"</span> <span class="k">then</span>
    <span class="nt">--</span> 焦点已经在 Chrome，不显示 alert
    <span class="k">return
  else
    </span>hs.alert.show<span class="o">(</span><span class="s2">"Chrome"</span><span class="o">)</span>
    hs.application.launchOrFocus<span class="o">(</span><span class="s2">"Google Chrome"</span><span class="o">)</span>
  end
end<span class="o">)</span>
</code></pre></div></div> <h3 id="示例2-不是焦点时获取应用焦点并打印图标">示例2: 不是焦点时获取应用焦点并打印图标</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hs.hotkey.bind<span class="o">({</span><span class="s2">"alt"</span><span class="o">}</span>, <span class="s2">"C"</span>, <span class="k">function</span><span class="o">()</span>
  <span class="nb">local </span>currentApp <span class="o">=</span> hs.application.frontmostApplication<span class="o">()</span>

  <span class="k">if </span>currentApp:name<span class="o">()</span> <span class="o">==</span> <span class="s2">"Google Chrome"</span> <span class="k">then</span>
    <span class="nt">--</span> 焦点已经在 Chrome，不显示 alert
    <span class="k">return
  else
    </span><span class="nb">local </span>chromeIcon <span class="o">=</span> hs.image.imageFromAppBundle<span class="o">(</span><span class="s2">"com.google.Chrome"</span><span class="o">)</span>

    <span class="nt">--</span> 创建一个 canvas 显示图标
    <span class="nb">local </span>iconCanvas <span class="o">=</span> hs.canvas.new<span class="o">{</span> x <span class="o">=</span> 0, y <span class="o">=</span> 0, h <span class="o">=</span> 100, w <span class="o">=</span> 100 <span class="o">}</span>:appendElements<span class="o">({</span>
      <span class="nb">type</span> <span class="o">=</span> <span class="s2">"image"</span>,
      image <span class="o">=</span> chromeIcon,
      imageAlignment <span class="o">=</span> <span class="s2">"center"</span>,
      imageScaling <span class="o">=</span> <span class="s2">"scaleToFit"</span>
    <span class="o">})</span>

    <span class="nt">--</span> 获取屏幕中心位置，显示 canvas
    <span class="nb">local </span>screenFrame <span class="o">=</span> hs.screen.mainScreen<span class="o">()</span>:frame<span class="o">()</span>
    iconCanvas:frame<span class="o">({</span>
      x <span class="o">=</span> screenFrame.w / 2 - 50,
      y <span class="o">=</span> screenFrame.h / 2 - 50,
      h <span class="o">=</span> 100,
      w <span class="o">=</span> 100
    <span class="o">})</span>

    <span class="nt">--</span> 显示图标，并在1秒后自动删除
    iconCanvas:show<span class="o">()</span>
    hs.timer.doAfter<span class="o">(</span>1, <span class="k">function</span><span class="o">()</span> iconCanvas:delete<span class="o">()</span> end<span class="o">)</span>

    hs.application.launchOrFocus<span class="o">(</span><span class="s2">"Google Chrome"</span><span class="o">)</span>
  end
end<span class="o">)</span>
</code></pre></div></div> <p>bundle id可以通过命令查看(下面的示例里封装了自动获取bundle id)</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>osascript <span class="nt">-e</span> <span class="s1">'id of app "iTerm"'</span>
osascript <span class="nt">-e</span> <span class="s1">'id of app "Google Chrome"'</span>
</code></pre></div></div> <h3 id="示例3-打开应用">示例3: 打开应用</h3> <p>跟2类似，封装了一下，可以复用</p> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 1. Open Application --</span>
<span class="k">function</span> <span class="nf">getBundleID</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">app</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">app</span> <span class="k">then</span>
    <span class="k">return</span> <span class="n">app</span><span class="p">:</span><span class="n">bundleID</span><span class="p">()</span>
  <span class="k">else</span>
    <span class="c1">-- 如果应用未运行，通过应用路径获取</span>
    <span class="kd">local</span> <span class="n">appPath</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">pathForBundleID</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">appPath</span> <span class="k">then</span>
      <span class="k">return</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">infoForBundlePath</span><span class="p">(</span><span class="n">appPath</span><span class="p">).</span><span class="n">CFBundleIdentifier</span>
    <span class="k">else</span>
      <span class="n">hs</span><span class="p">.</span><span class="n">alert</span><span class="p">.</span><span class="n">show</span><span class="p">(</span><span class="s2">"Application not found: "</span> <span class="o">..</span> <span class="n">appName</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1">-- 通用函数，用于绑定热键并处理应用程序启动或聚焦</span>
<span class="k">function</span> <span class="nf">bindAppHotkey</span><span class="p">(</span><span class="n">modifiers</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">appName</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">bundleID</span> <span class="o">=</span> <span class="n">getBundleID</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">bundleID</span> <span class="k">then</span>
    <span class="k">return</span>
  <span class="k">end</span>

  <span class="n">hs</span><span class="p">.</span><span class="n">hotkey</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">modifiers</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span>
    <span class="kd">local</span> <span class="n">currentApp</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">frontmostApplication</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">currentApp</span><span class="p">:</span><span class="n">bundleID</span><span class="p">()</span> <span class="o">==</span> <span class="n">bundleID</span> <span class="k">then</span>
      <span class="k">return</span>
    <span class="k">else</span>
      <span class="kd">local</span> <span class="n">appIcon</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">image</span><span class="p">.</span><span class="n">imageFromAppBundle</span><span class="p">(</span><span class="n">bundleID</span><span class="p">)</span>

      <span class="c1">-- 创建一个 canvas 显示图标</span>
      <span class="kd">local</span> <span class="n">iconCanvas</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">new</span><span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">}:</span><span class="n">appendElements</span><span class="p">({</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="s2">"image"</span><span class="p">,</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">appIcon</span><span class="p">,</span>
        <span class="n">imageAlignment</span> <span class="o">=</span> <span class="s2">"center"</span><span class="p">,</span>
        <span class="n">imageScaling</span> <span class="o">=</span> <span class="s2">"scaleToFit"</span>
      <span class="p">})</span>

      <span class="c1">-- 获取屏幕中心位置，显示 canvas</span>
      <span class="kd">local</span> <span class="n">screenFrame</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">screen</span><span class="p">.</span><span class="n">mainScreen</span><span class="p">():</span><span class="n">frame</span><span class="p">()</span>
      <span class="n">iconCanvas</span><span class="p">:</span><span class="n">frame</span><span class="p">({</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">screenFrame</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">screenFrame</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">100</span>
      <span class="p">})</span>

      <span class="c1">-- 显示图标，并在1秒后自动删除</span>
      <span class="n">iconCanvas</span><span class="p">:</span><span class="n">show</span><span class="p">()</span>
      <span class="n">hs</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">doAfter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="n">iconCanvas</span><span class="p">:</span><span class="n">delete</span><span class="p">()</span> <span class="k">end</span><span class="p">)</span>

      <span class="c1">-- 启动或聚焦应用程序</span>
      <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">launchOrFocus</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">-- 使用通用函数为不同的应用程序设置热键</span>
<span class="n">bindAppHotkey</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"C"</span><span class="p">,</span> <span class="s2">"Google Chrome"</span><span class="p">)</span>
<span class="n">bindAppHotkey</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"S"</span><span class="p">,</span> <span class="s2">"Sublime Text"</span><span class="p">)</span>
<span class="n">bindAppHotkey</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"space"</span><span class="p">,</span> <span class="s2">"iTerm"</span><span class="p">)</span>
</code></pre></div></div> <h3 id="示例4-热键转移再触发">示例4: 热键转移，再触发</h3> <p>抛开应用开启，某些情况下需要其他功能，比如截图，这个时候本身截图是在应用里设置的热键，这种情况就需要通过一下小技巧转移热键，等于代理了</p> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 2. retrigger --</span>
<span class="n">hs</span><span class="p">.</span><span class="n">hotkey</span><span class="p">.</span><span class="n">bind</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"A"</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span>
  <span class="n">hs</span><span class="p">.</span><span class="n">eventtap</span><span class="p">.</span><span class="n">keyStroke</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">,</span> <span class="s2">"cmd"</span><span class="p">},</span> <span class="s2">"A"</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
</code></pre></div></div> <p>这里就是在按<code class="language-plaintext highlighter-rouge">Option+A</code>的时候再触发按<code class="language-plaintext highlighter-rouge">Option+Cmd+A</code></p> <h1 id="参考">参考</h1> <ul> <li><a href="https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/">https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/</a></li> <li><a href="https://developer.apple.com/forums/thread/763878?answerId=804374022#804374022">https://developer.apple.com/forums/thread/763878?answerId=804374022#804374022</a></li> <li><a href="https://www.hammerspoon.org/">https://www.hammerspoon.org/</a></li> </ul>]]></content><author><name></name></author><category term="tricks"/><category term="MacOS"/><summary type="html"><![CDATA[背景]]></summary></entry><entry><title type="html">观点认同问题 / The Challenge of Opinion Shaping in the Digital Age</title><link href="https://ifuryst.github.io/blog/2024/the-challenge-of-opinion-shaping-in-the-digital-age/" rel="alternate" type="text/html" title="观点认同问题 / The Challenge of Opinion Shaping in the Digital Age"/><published>2024-10-09T15:19:27+00:00</published><updated>2024-10-09T15:19:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/the-challenge-of-opinion-shaping-in-the-digital-age</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/the-challenge-of-opinion-shaping-in-the-digital-age/"><![CDATA[<p>很久以前看到一个说法，原话记不清楚了，但是大体的意思是，现在人的观点太容易被互联网上的言论给左右了，可能你现在看到这个观点你觉得很有道理，一会你又看到了另外一个观点，同样也觉得很有道理，你的观点在不断的被左右</p> <p>一直以来我都认为这个说法很对，我很认可（这个时候我就是故事中的人了），但是今天我开始有点质疑这个说法了。</p> <p>首先是我觉得互联网就是这么个神奇的东西，这个世界那么多人，都能在这之上很迅速很便捷的进行交流，因此也衍生出了一批自媒体，广义层面的，比如我写的这些文章，我可以很简单的发布到网上，会有人看得到。在这种角度来看，你能看到你认可的观点我觉得没有丝毫可称奇的地方。</p> <p>我们能看到某篇文章、某个说法、某个观点等等，进而认可，我觉得原因有很多了，比如作者本身的表述就相对来说很自洽，很容说服人，我觉得在庞大的网民群里之上，你能看到的毕竟是少数，这些内容从某些层面就是更佳有突出重围的优势。这其中也不乏各类推荐算法，使得我们更加容易获取到自身认可的信息。</p> <p>因此我觉得从获取信息的角度来看，这没什么问题，我们认可观点也是非常自然的事情。从辩论或者论证的角度，有些情况下我们很有可能同时认可正反双方的观点，这也会让我们感觉自己像是“墙头草”，对正反观点都觉得很有道理很认可。</p> <p>另外就是自我们自己的思维不够完备不够自洽的情况之下，我们会更容易接受别人的观点，我觉得这也无可厚非。如果我们从一开始就抱着文章开头的想法，时刻提醒自己不要被这些观点随意左右，那很有可能我们会进入一种误区，毕竟我觉得谁也不敢保证在某些方面的观点从一开始就是对的？如果你不持续接收外部的观点来影响自己，那思想如何进一步完善呢？因此如果轻易采信，可能也间接说明了太容易被其他人的观点影响了，进一步固步自封了？这里有点套娃的感觉，如果你觉得这句话有道理，你就有可能是这句话里面表达的那种人。</p> <p>因此我觉得哪怕被各类观点带着跑，依然可以尝试去理解别人的观点立场，这样有助于形成自己的判断。但是这里面也有不少陷阱啦，比如现在的仇恨言论化，观点极化，非黑即白，本身就是互联网短平快带来的副作用，因此我们应该警惕这些点，进一步形成自己的小宇宙。</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[很久以前看到一个说法，原话记不清楚了，但是大体的意思是，现在人的观点太容易被互联网上的言论给左右了，可能你现在看到这个观点你觉得很有道理，一会你又看到了另外一个观点，同样也觉得很有道理，你的观点在不断的被左右]]></summary></entry><entry><title type="html">用科学的手段重新认识习以为常的事物 / Reevaluating the Familiar Through a Scientific Lens</title><link href="https://ifuryst.github.io/blog/2024/reevaluating-the-familiar-through-a-scientific-lens/" rel="alternate" type="text/html" title="用科学的手段重新认识习以为常的事物 / Reevaluating the Familiar Through a Scientific Lens"/><published>2024-09-30T15:12:27+00:00</published><updated>2024-09-30T15:12:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/reevaluating-the-familiar-through-a-scientific-lens</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/reevaluating-the-familiar-through-a-scientific-lens/"><![CDATA[<p>我们有很多的认知都来源于代代口述相传和切身感受的经验组成，尤其是对于很多日常中出现的事物，而且这些东西在教育体系中鲜少涉及（部分专业学习中可能会涉及），这会导致一些认知的固化，并且会完全没有意识去翻新陈旧或者错误的认知。</p> <p>其实对于这个想法由来以久了，在很长的一段时间内我都会时不时留意到这个问题，但是存在这么久也是有原因的，我仔细思考了一下，有这么几个原因：</p> <ol> <li>惯性太强</li> <li>惰性太强</li> <li>没有找到更易于入手理解的完整的知识</li> </ol> <p>最近在阅读一本叫做《睡眠革命》（尼克·利特尔黑尔斯）的书，以上的念头再次涌上心头。借此机会以睡眠这个事情来聊聊这个话题</p> <p>对于睡眠，我的看法经历过很多次变化，大体如下：</p> <ul> <li>小时候需要充足的睡眠，晚上也能很轻松入睡</li> <li>青少年时期会熬夜玩电脑玩手机，白天睡到自然醒</li> <li>大学时觉得自己不能睡太多，开始管理自己尽可能早点起床</li> <li>觉得自己死了可以长眠，强迫自己不多睡</li> <li>毕业后创业，作息相对不规律，但仍能保持相对规律的睡眠</li> <li>现在是拒绝午睡，晚睡早起但需要修复</li> </ul> <p>现在看看其实这里面存在很多的认知错误已经错误的决策，不过好在目前还没有造成比较严重的后果，我仍然有机会进一步科学的矫正自己对于睡眠的认知，并作出更好的决策</p> <h2 id="早睡星人和晚睡星人">早睡星人和晚睡星人</h2> <p>结合这本书来看一下，书中说到，睡眠分为2个类型：</p> <ol> <li>早睡星人：早睡早起，甚至不需要闹钟</li> <li>晚睡星人：早睡困难早起困难</li> </ol> <p>我觉得蛮多现代的年轻人会将自己归类到第二类，我觉得我是偏向第二类的，我经常很惊讶和赞叹我的某些朋友可以做到早上很早就自然醒的能力，虽然我通过自我约束和强迫能达到类似的状态，但是我做不到靠生物钟之类的内在力量做到。</p> <p>书中也提到，这个社会的制度似乎天然会对晚睡星人不友好，我们姑且相信这两类人是客观存在的，因为有一些观念会偏向性的认为，晚睡的人就是“有问题”，我觉得这个也是一个非常令人讨厌和心痛的问题。以我个人以及周边人的经历来说，父母们会叫你早睡早起，不希望你晚起，希望你起来吃早餐，一切的出发点看着都是没有问题的，但是问题在于劝导方式非常难以接受，甚至进一步造就了我们的认知：</p> <ul> <li>觉得失眠的人是有问题，但是我们应该正视一些疾病存在的可能</li> <li>觉得不早睡是玩电脑、玩手机或看电视之类的问题，这个是客观存在</li> <li>觉得晚起不好，但是怎么不好却经常挺难说出来的，以及一位的劝导早起</li> </ul> <p>不过我觉得也无可厚非，这也是教育的意义吧，因为以我这个年龄来说，上一代人普遍的通识教育程度都比较低，更遑论针对性的学习。我觉得我们应该更加科学的看待这些问题，比如书中提到的几个点都非常棒，我们一起来看看</p> <h2 id="昼夜节律">昼夜节律</h2> <p>人类从农耕文明一直到现在，经历过很多次的大革命，但是物种的进化速度是很慢的，因为我们还保留了农耕时代的作息规律，也就是夜间睡眠，白天劳作的规律，在一天24小时的过程中，人体的状态也分了好多个阶段。</p> <p>这里我们可以了解到夜间9点多的时候释放褪黑素，</p> <h2 id="15h一个周期的r90方案">1.5h一个周期的R90方案</h2> <p>其实我一直有这个迷思，同样的睡眠时间，7点起，8点起，有可能后者更加困，那就很奇怪了，明明我多睡了一小时了呀？为什么我更困了呢。以前我自己感悟出来的是：我觉得睡眠是有个周期的，你超过这个周期如果没睡满就很困，但是我不知道如何能完美的卡到这个档，也不知道周期有多长。</p> <p>本书作者给出了一个叫做R90的方案，也就是以90分钟（1.5h）为周期，人一天需要4或者5个周期。作者建议，如果你能完成一整个周期的睡眠是最好的，如果不能你可以考虑放弃掉这个周期。比如说5个周期为例子，00:00睡到7:30是5个周期，如果你在01:00的时候还没睡，你可以考虑让自己在黑暗的环境下（促进褪黑素分泌已经精神放松）放松30分钟后入睡，这样你拥有了4个完整周期，这种情况可能会好过直接入睡</p> <h2 id="睡懒觉-可控修复期">🚫睡懒觉 ✅可控修复期</h2> <p>我现在不午睡了，一半是我习惯了，另一半是我能忍住。我以前也会午睡，但是自从我每天中午开始学习英语后，我放弃了午睡。对于午睡就像前面说到的，我似乎不想让我自己进行午睡，我更希望好好利用这个时间来做一些我自认为有意义的事情。</p> <p>这本书给我一个比较惊奇的点就是这个可控修复期了，书中作者将午睡的概念表述成可控修复期，我非常非常喜欢这个称呼。我会更加有意愿的去平衡午睡和不午睡的时间，因为如果我希望自己的身体能保持健康，我应该至少空出一点点时间让身体进行修复（比让自己睡一会来得更能接受）。</p> <h2 id="深睡眠与人体生长激素">深睡眠与人体生长激素</h2> <p>关于睡眠的力量，书中多处表述。有一个点我觉得很重要的是：深度睡眠（占睡眠时长的20%左右，但是以Apple Watch帮我监控得到的数据，我可能5%而已[1]，有点可怕）会帮助身体进行修复。</p> <blockquote> <p>美国临床心理学家、睡眠专家迈克尔·J.布利乌斯博士宣称，睡眠的胜利修复功效大多产生于这一阶段，比如生长激素分泌量的增加。人体生长激素是一种能促进新细胞生长和组织的修复、让人体能在日常劳作后获得休整、让人（并让人感到）恢复生机与活力的关键成分，我们都离不开它。</p> </blockquote> <p>这个也是我从来不知道的，如果我知道深度睡眠这么厉害，以我的性格，我应该会尝试去追求一下深度睡眠（这也是我现在的一个小小目标，通过这个小追求让我进一步获得更好的睡眠质量，进一步高效的修复自我，进一步的支撑我在日间有能量做我想做的事情）</p> <h2 id="多相睡眠">多相睡眠</h2> <blockquote> <p>在一个生产力至上的社会中，分段式睡眠似乎纯属浪费时间</p> </blockquote> <p>现在大家基本都是晚上睡觉，可能加个午睡。作者还谈论到，在以前，人类对于多相睡眠是极其自然的。除了午间以外，其实在傍晚的时候，人的睡眠冲动是不断下降的，但是睡眠需求却处于峰值。这点我还蛮有感触的，自从我不午睡之后，我时不时的在6-7点这个时间段感到极为困倦，不论是在开车犯困还是到家躺在沙发上直接睡着都是身体在不断提醒我我应该休息一下（尽管我一直无视这个信号）。</p> <h2 id="总结">总结</h2> <p>如果没有以较为全面科学的方式去重新认识睡眠，我们会了解什么是褪黑素，褪黑素有什么用么？还有可能觉得睡懒觉是有负罪感的。我们也无法认知到睡眠周期和睡眠阶段组成。</p> <p>每个人都能用30年、40年的时光来度过自己的前半生进入中年，然后觉得自己经历很多了，觉得自己可以传授自己的认知给后来者了。这中间的问题就在于你以为你以为的，其实并不是那么一回事，在你认知里它是对的，是真理的，是经过实践的真知。但是或许有一天（不管你还在不在世），有人（可能是你也可能是别人）会质疑你的这个观点，并进一步完善自己的观点传授给下一个人。这个世界就是这么有趣也这么无趣，从贯穿人类史的时空维度上，我们就是在这个模式之下不断重复演绎相同故事的镜像。区别在于，我们建立了这样的体系，我们能保存和传播知识，并有机制能反向推到前人的知识，建立新的知识。</p> <p>我们似乎追求到了更加“正确”的知识。</p> <p>但是这代表了我们的认知水平一代比一代更好么？从通识角度来说，我认为是的。但是人的一生是有限的，精力也是有限的，社会需要的人才是市场化的，这就导致了，知识在某个领域演变得越来越复杂（哪怕不复杂，随时间演变不断堆砌的信息量也会）导致一个人很难能掌握很多领域的知识，因此通才或全才已经演变成专精某个或某几个领域的人才，这也是现在这个社会，尤其是市场化和资本化主导的世界的现状。</p> <p>你，还想用科学的手段重新认识习以为常的事物么？</p> <p>[1]：修订一下，可穿戴设备的统计并不准确，比如根据加速计结合动作判断是深度睡眠还是浅睡眠；真正能提供准确数据的是诸如多导睡眠脑电图和一些头戴式睡眠监测仪等。因此实际上我们可以结合自我的感觉来判断，早晨起来觉得精力充沛的同时Apple Watch显示深度睡眠很少，这个时候应该相信什么呢？</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[我们有很多的认知都来源于代代口述相传和切身感受的经验组成，尤其是对于很多日常中出现的事物，而且这些东西在教育体系中鲜少涉及（部分专业学习中可能会涉及），这会导致一些认知的固化，并且会完全没有意识去翻新陈旧或者错误的认知。]]></summary></entry><entry><title type="html">技术革命中的博弈 / Competing Forces in the Tech Revolution</title><link href="https://ifuryst.github.io/blog/2024/competing-forces-in-the-tech-revolution/" rel="alternate" type="text/html" title="技术革命中的博弈 / Competing Forces in the Tech Revolution"/><published>2024-09-22T13:41:27+00:00</published><updated>2024-09-22T13:41:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/competing-forces-in-the-tech-revolution</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/competing-forces-in-the-tech-revolution/"><![CDATA[<p>人类历史以来有过多次大型的技术革命，也有很多更小一点的技术突破和应用。在这些技术的应用和演进过程中伴随着很多的摩擦碰撞和协商妥协。</p> <p>我们听说过这样的说辞：新的技术出现会导致一些旧的职业消失，但同时也会创造一些新的就业，从长远角度看是对人类有好处的。</p> <p>我们一起来看看这里面的关键点：</p> <ol> <li>首先新技术会导致一些职业消失，这点我觉得毋庸置疑的，尤其是工业革命、互联网这些关键技术的应用会导致很多职业的消失，很多人会因此下岗失业。</li> <li>其次是创造新就业，我觉得这点也是正确的，新的岗位会出现。</li> <li>长远角度看对人类有好处，根据历史来看，似乎确实是这样的，从大的数据角度比如GDP或者社会财富总值来看是符合这个预期的。</li> </ol> <p>但是我们将其组合起来看，是可以看出很多问题的，首先是一些比较直观的问题：</p> <ol> <li>失去工作的人并不会进入到新创造的岗位中。很多人所拥有的知识和技能不足以支持他在岗位消失就找到比现有工作更好的工作，除非她有较好的再学习再教育能力，但是从客观事实来看，大部分人是不具备这个条件的，因素有很多，比如年龄问题，社会层面的保障支撑问题，个人视野层面问题等等。因此从某种角度来看这也是就业摩擦的一种，最终的结果就是这批人进入更差的岗位从事新的工作或者直接丧失就业能力。</li> <li>社会最优并不是个人最优。一个社会进步，从人类跨世代的宏观视角来说，技术的进步从长期来看会带给人类更好的生活，但是这期间可能是丧失了一部分2-3代人的生活。</li> </ol> <p>到这里我们也能看到矛盾所在了。如果掌权者或者拥有较大政治力量的群体的利益依托在那些会被新的技术所威胁的群体之上，那么新的技术的发展必然会受到较大或者完全的限制。反之亦然。</p> <p>因此长期的技术发展取决于很多短期的决策所组成。按照目前的AI应用的角度来看，我们是可以看到很多相关的例子的。AI目前已经发展到一定的程度了，已经几乎到了各行各业都可以从新结合AI重做一遍，这也导致了很多职业开始慢慢消亡，比如我们可以看到以好莱坞编剧和演员为主的创作者群体用罢工抗议来应对AI的应用推广。还有最近引发较多关注和讨论的加州SB1047。还有欧洲在AI层面走在世界前沿的例子。</p> <p>从这些不难看出就是各种利益在博弈。利益受损方必然会捍卫自己的利益，哪怕长远角度看对人类有好处的也不及其剩余的人生保障，这无可厚非。我觉得从客观角度大部分人很难做到从人类宏观视角来舍己为人，这完全不利己，不太符合市场驱动机制发展的社会。反过来看支持技术发展的往往是技术利益既得者以及利益不受损者。前者很好理解，诸如很多技术领域的企业，他们有理由推进技术发展并从中受益；后者也不难理解，利益不受损的人其实我们可以假待为中立的人，但是这些中立的人也会有偏向性，即他们分别会支持两个方向。</p> <p>看明白了这些，在对于一些政策的制定上，我们也可以从这个角度去看待各方参与者，分析他们的利益和观点由来，可能是个不错的观察点，这其中也包括我们自己😶‍🌫️</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[人类历史以来有过多次大型的技术革命，也有很多更小一点的技术突破和应用。在这些技术的应用和演进过程中伴随着很多的摩擦碰撞和协商妥协。]]></summary></entry><entry><title type="html">目标制定、标准衡量和人心管理 / Goal Planning, Performance Assessment, and Team Cohesion</title><link href="https://ifuryst.github.io/blog/2024/goals-metrics-n-team-spirit/" rel="alternate" type="text/html" title="目标制定、标准衡量和人心管理 / Goal Planning, Performance Assessment, and Team Cohesion"/><published>2024-09-17T13:41:27+00:00</published><updated>2024-09-17T13:41:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/goals-metrics-n-team-spirit</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/goals-metrics-n-team-spirit/"><![CDATA[<p>在做OKR或者目标的制定中，不管是季度还是年度的，本意应是好的，毕竟从企业的角度来看，能让一线的员工也能感知到公司级别的战略或者目标是一件很好的事情。但是在关于目标制定、迭代和最终结果评定以及绩效发放的过程中，有可能会变形。这个问题我思考过几次，现在我稍微有一些想法了。</p> <p>我想探讨的是个人的差异带来的向心力不足的问题，也就是减少团队内部猜忌所带来的的内耗。</p> <p>在一个团队内，通常是存在不同级别的人员的，有初级工程师也会有高级工程，甚至是资深工程师。在这种情况下，每个级别能达成的目标必然是不同的，因为能力、薪资待遇水平的差异，注定了高级别的人员理应产出更多的成果（先不论这些成果的价值），因此在制定目标的时候，最合理的必然是有差异化的难度水平，因为对于低级别的工程师来说，要起完成高级别工程师才能完成的目标，是有些强人所难了，也对他们不公平，因此对于每个级别，甚至是每个人都能有一个专门的目标，会最大化团队的能力。</p> <p>但是这也带来一定的问题：</p> <ol> <li>这就注定了，个人的目标在团队或公司级别的高纬度的目标内的体现有可能是一句话或者压根没体现。</li> <li>团队内除了Leader以外，可能某人对于其他人的目标情况和难易程度（在制定阶段）可能完全不care</li> <li>Leader有可能没有办法面面俱到地帮助每个人审核和把控其目标是否合理，可能只是做到了目标和上级的目标是否一致</li> </ol> <p>上面这些问题会分别带来一些不同的问题：</p> <ol> <li>某些幸运儿会拿到上一层级目标的完整词条，也就是上一层别的目标会落到某个或某几个员工身上，这会让这些人会有更大的压力和动力，相应的会更有价值感；而在上一层级目标中没有体现的人，会走向相反的方向，会更加没有价值感，驱动力可能会更加弱</li> <li>这个在制定目标初期并不会有任何问题，问题可能发生在过程或者结束的时候。因为在每个人的视角来看，可能会觉得别人的目标比自己轻松太多了（不论是主观还是客观），目标和职级不匹配，心生芥蒂，这是危险的种子</li> <li>这我喜欢称之为向上管理的一个例子。其实很多时候完成上级的目标没有问题，问题是你通过什么手段和方式来完成。如果你希望你的团队战斗力很强，那么最好不要草率的对待每个人的目标，尤其这个目标的持续时间比较长的情况下。最好能因人制宜，将目标和个人的意愿或规划做一定程度的匹配，当然这个会消耗管理者较多的时间</li> </ol> <p>我觉得这些问题大多能在前置环节解决，有些在过程中也能调整解决，关键在于能否识别。这里就需要看团队或者公司的文化和氛围是否有对应的机制去接收员工的反馈。不是每个人都会主动对团队或公司的发展出谋划策的，但是要有这样的机制能接收员工的反馈，这样才能知道团队是否出了问题，这有助于某些坏事情在滋生阶段就介入处理的。</p> <p>在目标制定阶段，在确定初版之后，我觉得有一个环节可以有蛮大收益的，让每个人对别人的目标做评价，这样他们可以认真去看别人的目标，这样可以在前置环节就让大家互相知道对方的目标，并且如果可以的话，可以问某个人如果xxx休假了，你可否代替她完成她的目标？一旦这个说法出来之后，这个人对于别人的目标的心态就会有些许变化了，可能就会开始带入自己是主人公的角色去思考，这样有助于大家对于目标制定达成共识。这点其实和敏捷迭代里的点数评估类似，比如某个任务，A需要2D完成，但是B只需要1D完成，这就是能力差异以及目标执行人的可替换性，其实不仅在迭代里可以这样，在目标的制定也是如此，我们不希望某个目标只能由某个人完成，我们其实应该至少保证有2个人以上可以完成某个目标，理想情况下当然是团队内每个人都可以完成任意的目标，但是出于对专业化分工的带来效率最大化的追求，通常是不会这样的，但至少我们可以保证有至少2人能完成某个目标。</p> <p>在目标的制定和规划上，管理人员不能只考虑自己的目标是否能完成，应该充分考虑将团队成员充分发挥起来，整个团队一起完成目标。参与感是一个很重要的东西。这里我想要举个有趣的例子来佐证这个观点：</p> <p>我们在做Scrum迭代的时候，正常是会有一个固定的Scrum master，负责组织站会、规划回顾会之类的敏捷会议。但是我们在实践过程中发现，与其设定一个固定的Scrum Master，不如让人人皆为Scrum Master，也就是轮流制，简单的实践方式是每周（假设迭代冲刺周期是1week）由不同的团队成员来担任Scrum Master。我发现这种方式带来的好处是远远大于前值的，主要集中在这么几点：</p> <ol> <li>每个人都能有机会成长，学会如何转从头到尾主持处理一次完成的敏捷迭代冲刺</li> <li>大家都会以主人公的意识来参与，当轮到别人做Scrum Master的时候你不会在旁边划水或者不怎么爱应答其发出的疑问，因为你知道当Scrum Master的感觉，也知道你提问的时候没人回应的感觉，你也希望下次你做Scrum Master的时候大家能配合你</li> <li>对于团队目标的追踪，你会开始上心，哪怕轮到你一次需要好几周，但是因为你已经开始注意目标的跟进了，你已经锚定了，因此你很容易就会将对应的信息听进去并且评估团队的情况</li> <li>团队内有管理能力的人会慢慢浮出水面，大家都得到了机会，作为管理者你可以很容易的观测到每个人在管理者的角度做事时是怎样的姿态，能帮助管理者更加容易的发现每个人的能力和定位，以及在遇到问题时候要怎样针对性的应对</li> </ol> <p>我并不是倡导一定要走轮流Scrum Master的方式，我只是觉得这种方式值得一试。这个例子说明是想说明如果你希望团队成员都动起来，首先需要让每个人尽可能找到主人翁的意识，这有挺多方法能达到的，我这里仅仅举了个例子。</p> <p>管理中最难的且最重要的永远是人，其次才是产品和利润（来自创业维艰），我觉得前者偏向于因，后两者偏向于果。因此我觉得好的管理是能人尽其才 🫡</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[在做OKR或者目标的制定中，不管是季度还是年度的，本意应是好的，毕竟从企业的角度来看，能让一线的员工也能感知到公司级别的战略或者目标是一件很好的事情。但是在关于目标制定、迭代和最终结果评定以及绩效发放的过程中，有可能会变形。这个问题我思考过几次，现在我稍微有一些想法了。]]></summary></entry><entry><title type="html">在确定性中寻找不确定性 / Seeking uncertainty in certainty</title><link href="https://ifuryst.github.io/blog/2024/seeking-uncertainty-in-certainty/" rel="alternate" type="text/html" title="在确定性中寻找不确定性 / Seeking uncertainty in certainty"/><published>2024-08-30T14:58:27+00:00</published><updated>2024-08-30T14:58:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/seeking-uncertainty-in-certainty</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/seeking-uncertainty-in-certainty/"><![CDATA[<p>一周前偶然在外图看到一本杨潇的《可能的世界》，起初吸引我的是类似游记的内容，小翻两页觉得内容似乎对味，因此就买了这本书。晚上吃晚饭随手拆看一看，竟是2小时过去了。</p> <p>算是一本在不同国家、地区的生活或经历结合一些自己的三观写出来的东西，我觉得非常引人入胜，其中有很多点非常棒。难免结合自己近一年来的生活进行了一定的印证和思考。</p> <h2 id="不确定性循环">(不)确定性循环</h2> <blockquote> <p>It’s easy to see the beginnings of the things, and harder to see the ends. (From Joan Didion) (Pxii)</p> </blockquote> <p>这是一句很能引起共鸣的话，很多时候我们只能看到事情的开始，看不到结束，这也是我们在这个世界剩余的日子里要不断经历的。</p> <p>昨天和一位同学简朋友聊，也聊到了对应的话。很多人的一生都是在追求一种确定性，这种确定性可以有很多现实的表征，也可以是一种心理上的确定性。但是也有一批人，在追求不确定性，不管她是在确定性中寻找不确定性还是在不确定性中寻找不确定性。</p> <p>怎么理解这个宛如绕口令的东西？无外乎利益。我们的一个共识是，原始动力皆为利益，哪怕亲情友情爱情，在广义上来说也是利益。在这里我认为利益并不是一个贬义词，我觉得更像是一个中性词，虽然很多时候我们很容易在向钱看的世俗意义中把利益当成一个偏向贬义词的词。</p> <p>为什么要寻找那一丝不确定性呢？有人为了机会，有人不喜欢按部就班的生活，有人为了找到更大的确定性。都说人的一生是在走出自己的偏见，在这里我们也可以说成，人的一生就是在确定性和不确定中不断循环，直到生命的终结。有人疲于奔命，有人一个循环都没走完。套用最近火出圈的黑猴，人人都想上个显卡当一回天命人，在黑猴的世界里，也是六道轮回，循环往复。</p> <h2 id="信息过载">信息过载</h2> <p>P48-P49说到一些关于信息过载的内容，比较散，就没有提取出原文了。这一点非常有感触。近一年来我的信息摄入量增加到非常可怕的地步，每天都在“赶进度”，每天都有看不到新闻、文章、paper推送，每天都要把newsletter都清掉，每天的commuting都需要听英文podcast，每天都要关注开源社区的邮件情况，还要把去年底带回来的基本英文书看完。准确来说近半年属于信息超级过载的状态，主要有几个原因：</p> <ol> <li>一定要尽可能接收（我认为的）正确的信息和一手的信息</li> <li>英语能力提升的同时伴随着对信息摄入的变态需求</li> <li>正向反馈，越是收到有价值的信息越激励自己去追求</li> </ol> <p>我觉得信息过载不是长期形态，我觉得最终的形态是会收敛到一个稳定的状态，我记得之前看纪录片Inside Bill’s Brain: Decoding Bill Gates，至今印象深刻的一个点是，Bill Gates会有一个时间，比如几天，开着飞机到某个地方，提了一袋书去闭关，让我震惊的是他阅读书籍的速度，快到不可思议，所以我觉得信息的摄入速度有很大的增长空间，当你的大脑不断重复一些pattern，他就能很快的判断内容，有点想神经网络训练后，很自然的就能知道下一个字符可能是什么…</p> <p>所以我觉得是一个做加法然后做减法的过程，一定要有一个量的积累，我不断在挑战自己的天花板，慢慢增加摄入量，一定要让自己保持在堪堪能catch up今天的信息流的进度，这个过程也不是一层不变，我会不断剔除不适合或不感兴趣的内容</p> <p>总得来说，我得出的结论就是，要让自己痛苦，让自己信息过载。当然方式有很多了，也有人是通过频繁和别人交流、交换思想来达成的，也有人是通过玩游戏、看电影、刷短视频达成的。</p> <p>最后，我觉得最值得一提的一点是，宝贵的信息永远不是免费的，也不能是免费的。我觉得比无法获取珍贵的信息更无法忍受的是获取错误的信息，这也是免费信息里的重灾区，太多的错误、无效信息，这也是我不喜欢短视频的一点，短视频让人很容易即时满足，但是其提供的往往不是我想要的，长视频可能还有一些尚可的内容。另外书籍真的是人类文明很重要的一个发明。还有一点，曾经我是非常不喜欢订阅制付费的人，我会非常稀罕那个费用，但是现在我愿意给任何一个信息、媒体平台一个机会，去订阅内容，如果是我想要的，我可以长期订阅支持，我觉得这是对正确信息的输出最直接的回报，我也希望能长期获得有深度的报道和分析。</p> <h2 id="思辨">思辨</h2> <p>P41, P38</p> <p>我非常喜欢哈佛来信这一章，这一张里讲的各类关于在哈佛大学里的所见所闻所思所想都非常吸引我。我是一个坚定的应试教育厌恶者（或许跟我本身没有那个应试教育的能力有一定关系吧😅），但是我对于知识的渴望是非常高的。</p> <p>文中有聊到一个课叫伦理、生物科学和人类未来，是两位教授迈尔克·桑德尔和道格拉斯·梅尔顿（Douglas A. Melton）一起上的，一人站在一边，然后通过对学生发问以及两位教授之间的辩论来完成的，非常有魅力和有趣，里面聊到关于运动员使用促红素（EPO）的观点，大体是EPO可以提高血液携氧能力，让肌肉工作更长时间，在运动领域这就类似兴奋剂的存在，教授列出总共有8种方法可以提升的，从最基础的锻炼休息，高海拔训练，低氧舱休息，到服用食物，转基因食物，再到注射。然后让学生选择哪个阶段你会投反对票，这也是国际奥委会实际在争论的问题。这个过程很有趣，大家都可以决定自己在哪个级别禁止，两位教授会就这个内容进行辩论。</p> <p>另外有一节聊到《纽伦堡的审判》，关于法庭上的对话也非常有意思。也给我带来了很大的思考。</p> <h2 id="自我她我">自我、她我</h2> <blockquote> <p>究竟是出于记录当下的冲动，还是为了迎合想象中的他者目光。(P46)</p> </blockquote> <p>这点也很有意思，对于发动态这件事情，咱们这个社会氛围之下，自然有两类主要的人，一类是热衷于发布自己的动态，一类是完全不发动态。当然还有其她类别的人，但是我觉得主要就这两类了。</p> <p>在亚洲的社会习俗或者社会观念之下，会有一些无形的东西在控住你的思想，这个讲不清是从小环境还是基因里多少带了一些千年的余韵。确实很多时候有这种考量，有时候只是当下的某些因素促使自己想去发布一个动态，但有些时候想的又是自己的人设问题。文中这句话倒真切的点出了这个。</p> <h2 id="写在最后">写在最后</h2> <p>这本书我还在看，就好像前面那句话一样，我只知道我什么时候开始看，我无法知道我什么时候能看完，如果还有有趣的内容，我还会继续更新一下这篇随笔。</p> <p>Let’s keep going. 🧗🏼‍♂️</p> <p>[*]<em>文中第三人称代指多用女性她，也是最近我学习到的，在某些英文资讯、文章中会以女性代词来代指，用于表明性别不明或不重要，也有避免性别歧视的一层含义，我觉得蛮有意义的。</em></p> <blockquote> <p>A user can choose her favorite serialization method to encode a message.(Forgive me. I forgot where this is from.. I’m retrieved if from ChatGPT’s chat history.)</p> </blockquote>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[一周前偶然在外图看到一本杨潇的《可能的世界》，起初吸引我的是类似游记的内容，小翻两页觉得内容似乎对味，因此就买了这本书。晚上吃晚饭随手拆看一看，竟是2小时过去了。]]></summary></entry><entry><title type="html">最高级的生活方式：存钱，早起，运动，读书 / Ultimate Adulting Hack: Stashing Cash, Racing the Sunrise, Sweating by Choice, and Pretending You Actually Finished That Book</title><link href="https://ifuryst.github.io/blog/2024/the-secret-to-peak-living/" rel="alternate" type="text/html" title="最高级的生活方式：存钱，早起，运动，读书 / Ultimate Adulting Hack: Stashing Cash, Racing the Sunrise, Sweating by Choice, and Pretending You Actually Finished That Book"/><published>2024-08-30T14:58:27+00:00</published><updated>2024-08-30T14:58:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/the-secret-to-peak-living</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/the-secret-to-peak-living/"><![CDATA[<p>说实话，这个标题恶心到我了………🤫</p> <p>今天在家庭群里看到一篇分享，是个不到10min的短视频，标题叫《最高级的生活方式：存钱，早起，运动，读书》，刚好我洗完澡在餐桌上看点材料，心血来潮的回复了一段话：</p> <blockquote> <p>感觉能认识到自己想要的和追求的，有理想也有现实，有事业也有家庭，能平衡好自己的生活，自己认为好的生活方式就是最好的。不过这里面很多点，很多人一辈子都没有看明白。怎么说一个人一辈子都是在走出偏见的过程。读书学习，遇人识物，出门旅行，都是不同的方式。</p> </blockquote> <p>人的一生都在追求什么？</p> <p>我觉得很多人都有自己的答案，也有挺多人知道自己有答案，但是不敢或者不想去揭露那个答案，有时候朦胧也是一种美。</p> <p>当然也有一些人可能不知道或者还不知道自己的追求是什么。这其中也有很多原因，如果单独从不知道追求什么就先入为主的认为，可能会有一些相对偏见的结果。</p> <p>从很小我就开始为自己的人生做决定，我不会后悔自己做的事情，习惯性没有这个想法，也不知道是逃避还是真如自己认为的“我永远会对自己的决定负责到底”，这也让我在做每个重要决定之前会想的多一点。姑且认为是后者，我觉得做决定还挺简单的，难的是，你要在有限的选择里做出更好的决定，以及随之而来的伴随你的决定的一切结果。</p> <p>我也同很多人一样，觉得成年人的世界更加复杂。但是我乐爱成年人的世界，因为我有能力也有足够的见识支撑我做出更加重要的决定，这个在比较小的年龄来说，是很难的，因为见识和经历太少，很多时候做出正确的决定也有一定的运气在里面（其实成年人的世界做决定也逃不过这个，只是成分多寡的区别），并且也没有太多物质能力支撑你做更广的选择。从某些层面来看，成年人的选择会更多一些，但是也挺多时候可以发现一样是非常有限的选择，甚至没有选择。</p> <p>回过头来，其实很多时候我知道自己追求的是什么，自己想要的是什么，我对于自己的中期规划会比较擅长，短期会比较倾向于在中期计划里野蛮生长，我喜欢在有限的自由里这样做，就好像小时候最喜欢画自由画一样，我必须要提交一份画，这个是边界，在此基础之上，我可以畅想并画任何我想画的，我觉得这个也是能在一定程度内让自己保持有创造力的表现，在这个空间之下，去跳脱。不过也有另一面（On the flip side），很多事情会混乱起来，我觉得这个事情有一些人很难接受，比如你会让你的桌面很乱，但是其实这是外人眼里的乱，包括在严肃一些的场景之下，可能会被人冠以没有条理性之类的帽子。但是这个乱在我的世界中都有各自的定位，我在里面能随心所欲的实施很多想法，以我刻板和有限的对艺术家或者创作者的想法和认知来看，我认为这个是有一定共性的（欢迎有人随时来打我的脸）。</p> <p>就这样，我会以中期规划做锚点，来指导我的某些短期行为（但是这并不代表我会事事照着这个来，那样可太无趣了）。你可能发现少了一个长期规划或者远期规划，我觉得这是一个很难的事情，就我个人而言。我觉得太远的规划存在的意义值得商榷，我不太喜欢把事情想得那么远，因为有可能落入一些陷阱。</p> <p>比如有的人会说，理想总要有的，万一实现了呢。这种会把长期规划当作一种偏向于比较难实现的东西去想。还有一种是偏向比较可实现的方向去想，这种相对前面那种会好一点，但是我觉得都不是很有意义，我的观点是，太容易随着时间流逝，经历的不同东西，体验到不同的事物而改变了。还有一个点就是，规划某种程度上说可能是给自己设限，因为你期望按照这个方向走，所以也有割伤自己的嫌疑。当然这一切都是基于我的认知所想的，我相信有很多人和我的观点相左，我愿意接受一切和我观点相似或者相反的想法存在，多样性的意义大概如此。</p> <p>口嗨了这么多，其实也只是在口嗨。从一个生活方式的分享视频说到人生追求，再扯到选择和决定，最后再胡诌一下规划，这大抵就是成年人的自由画。我也不太可能在这里把我的生活方式、追求、决定、选择和规划相关的东西都剖析得一干二净，只是希望能给大家，给这个世界带来一点个人观点和想法。That’s enough :)</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[说实话，这个标题恶心到我了………🤫]]></summary></entry><entry><title type="html">Kafka设计理念 / Kafka Design Concept 📝</title><link href="https://ifuryst.github.io/blog/2024/kafka-design-concept/" rel="alternate" type="text/html" title="Kafka设计理念 / Kafka Design Concept 📝"/><published>2024-08-29T14:18:27+00:00</published><updated>2024-08-29T14:18:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/kafka-design-concept</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/kafka-design-concept/"><![CDATA[<p><a href="https://notes.stephenholiday.com/Kafka.pdf">https://notes.stephenholiday.com/Kafka.pdf</a></p> <p>依然建议点开这个链接，先读一下原始信息，读完后仍然感觉有必要的情况下再来阅读本文，避免被我提供的信息先入为主影响你的思考。 当然你反过来阅读也可以，可以先通俗阅读后去原文里印证一下想法，也是一种方式。Whatever you prefer.</p> <h2 id="背景">背景</h2> <p>Kafka是2011年LinkedIn开源的，后来捐给ASF了，现今到一定规模的企业基本没有不涉及到使用Kafka的可能，这是一个很重要的基础设施。</p> <p>Kafka诞生的初衷是因为传统的日志处理、聚合和消息系统在某些程度上都不满足一些场景下的需求，包括：</p> <ol> <li>过度递送保证了，比如强事务、强ACK等，这个在某种程度上会牺牲能处理的量级，并且在某些场景并不是完完全全关心这个保证，比如某些日志丢失一两条可能并没有什么问题。</li> <li>大多数系统并不是以吞吐量优先的原则进行设计的，比如里面提到的JMS甚至不支持批量发送消息，这会导致每个消息都需要一个完整的网络请求来回时间（Roundtrip）</li> <li>对于分布式支持较弱</li> <li>大多数消息系统都假设下游接近实时消费，堆积量很小。这个在大量堆积的场景会引发很严重的性能问题（某些采用push给下游的，还可能导致更严重的问题）</li> </ol> <p>所以我个人感觉，Kafka其实是技术或者说行业量级发展到一定程度必然会产生的一个产物，因为在数据量级日益增长的情况下，必然需要这样一个基础设施、 中间件、消息队列来持续以高吞吐可靠的处理高量级（High Volume）的数据，并且能有分布式的支持来应对灾难， 其他的就是一些相应的feature了， 比如可靠性、可堆积、可重复消费、PULL代替PUSH等</p> <h2 id="设计理念">设计理念</h2> <p>基于前面的背景，大概也能知道Kafka会是什么样子的，以下是一些基础的概念、术语：</p> <ol> <li>Message：经过的数据都叫消息</li> <li>Topic：特定的消息流被定义在topic里</li> <li>Producer：可以发布消息到topic</li> <li>Broker：实际保存数据的服务器</li> <li>Consumer：可以从一个或多个topic里订阅读取消息（PULL）</li> <li>Partition：基于topic下的逻辑分区</li> </ol> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-28-kafka-design-concept/kafka_architecture.2024-08-28_13-44-48-480.webp 480w,/assets/img/2024-08-28-kafka-design-concept/kafka_architecture.2024-08-28_13-44-48-800.webp 800w,/assets/img/2024-08-28-kafka-design-concept/kafka_architecture.2024-08-28_13-44-48-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-28-kafka-design-concept/kafka_architecture.2024-08-28_13-44-48.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Git History </div> <h3 id="简单存储">简单存储</h3> <p>日志被分成固定大小的文件（Segment file），比如1G。为了提高性能，每次收到消息后会换存在内存，等到一定消息量或经过一定时间后， 才会被写到（flush）磁盘，只有在写到磁盘后才可以被消费者消费</p> <p>Kafka的消息并没有message id，而是以逻辑偏移（logical offset）来定位。这能避免寻址的开销，如随机访问等。kafka的id是递增的但是不连续， 因为下一个消息的偏移需要用当前的消息id+消息长度</p> <h3 id="传输效率">传输效率</h3> <p>利用了底层操作系统的页缓存（page cache），这样的好处是Kafka自己不需要管理这些内存了，操作系统自己管就行了，没有命中的页再去磁盘load进来， 操作系统自己有一套完备的内存页管理机制；另外就是减少了GC的开销了，不需要对这部分数据的GC头疼了。这种情况下可以支持TB级别的数据消费</p> <p>另外就是利用了系统调用（system cal）来减少数据在内核和用户空间拷贝的开销，这个也是很聪明的一个设计， 按照常规从磁盘读数据通过网络发送的应用来说，大体是这样一个过程：</p> <ol> <li>从磁盘读取数据到操作系统页缓存，此时数据在内核态</li> <li>从内核拷贝数据到用户空间的缓存里</li> <li>然后要通过网络发出去的话，从用户空间的应用缓存里再拷贝到内核缓存空间</li> <li>从内核缓存空间发给socket</li> </ol> <p>前后经过4次数据拷贝，2次系统调用。在这种情况下Kafka通过系统调用（如linux里的sendfile）可以直接把数据从磁盘给到socket， 可以减少步骤2、3的操作了，等于简化到2次数据拷贝，1次系统调用（也有的地方会称为0拷贝，我觉得这个说法应该是针对0次拷贝到用户空间的说法）</p> <h3 id="无状态broker">无状态Broker</h3> <p>broker不知道消费者的任务信息，都有消费者自己管理，因此broker极度简化，但是这也带来一个问题，就是broker不知道什么时候才能删掉消息， 所以Kafka采用了通过以时间为基准的SLA保留策略，比如7d、30d、90d这种，在实际生产环境中是完全可行的，正常下游不会不可用或者lag到这么久， 这个设计的另外一个好处是，消费者可以自主回滚offset或者重新拉取之前的消息，在某些故障场景下， 可以很好的结合一些诸如checkpoint机制来保障下游数据的可靠性。</p> <p>当然这个设计是违背常规队列的设计的。这也是一个很不错的点，就好比人人都和你说队列就应该这样设计，如果你一直遵从这种思维， 你设计的消息队列就有可能先入为主的沿着这个方向去思考，所以有时候能打破旧有的标准，敢于挑战权威是一种勇气也是一种能力</p> <h3 id="分布式协调">分布式协调</h3> <p>抛弃主节点的设计，结合了Zookeeper做Consumer的协调，主要针对topic和partition以及offset，具体涉及了4个注册表（registry）：</p> <ol> <li>Broker Registry(ephemeral)：存放broker注册信息，启动时会注册</li> <li>Consumer Registry(ephemeral)：消费者加入consumer group的时候会创建注册</li> <li>Ownership Registry(ephemeral)：当一个消费者声明自己负责某个partition的时候，会创建表明所有权</li> <li>Offset Registry(Persistent)：存储消费者消费到的偏移量，每个partition一个节点，值表示最新已提交的消息偏移量</li> </ol> <h3 id="递送保证">递送保证</h3> <p>Kafka只支持至少一次，并不支持准确一次。但后面的迭代中还是加入了ACK等机制，只是最初设计是还没有做这个。</p> <h2 id="结论">结论</h2> <p>整体从最初的设计理念可以看出，Kafka对于非常重要的数据的保障并没有做到最好，也就是跟传统的日志服务不同，更注重低时延高吞吐。 比如一开始并没有ACK机制，Broker也不支持数据副本，这些也在后续陆续被支持。Kafka后续也迭代增加了很多Feature，甚至现在都用KRaft取代了ZK， 单看一篇最初始的Paper并不能了解所有，只能窥探最初的设计理念，但是后面演进过程中也有很多的有趣、很棒的设计， 具体可以看相关的<a href="https://cwiki.apache.org/confluence/display/KAFKA/Kafka+Improvement+Proposals">KIP（Kafka Improvement Proposal）</a></p> <p>PULL vs PUSH模型也是一个很有意思的选择，Prometheus和Kafka在他们的场景都采用了PULL，是从一定的出发点、设计理念和背景下做出的这个选择。 进一步可以说明并没有什么银弹，很多时候是在一定的背景和场景之下去选择合适的方案，是一种能力也是一种智慧。</p> <h2 id="appendix-1">Appendix 1</h2> <p>以下内容基于Kafka 2.4.1</p> <table> <thead> <tr> <th>ZK路径</th> <th>内容示例</th> <th>作用</th> </tr> </thead> <tbody> <tr> <td>/admin</td> <td> </td> <td>Kafka管理任务的信息</td> </tr> <tr> <td>/admin/delete_topics</td> <td> </td> <td>删除topic操作信息存在这里</td> </tr> <tr> <td>/brokers</td> <td> </td> <td>broker信息</td> </tr> <tr> <td>/brokers/ids/<broker_id></broker_id></td> <td>{<br/> “listener_security_protocol_map”:<br/> {<br/> “PLAINTEXT”: “PLAINTEXT”<br/> },<br/> “endpoints”:<br/> [<br/> “PLAINTEXT://10.123.123.1:9092”<br/> ],<br/> “jmx_port”: 9989,<br/> “host”: “10.123.123.1”,<br/> “timestamp”: “1722923239941”,<br/> “port”: 9092,<br/> “version”: 4<br/>}</td> <td>具体的broker信息，ID，端口，注册时间等</td> </tr> <tr> <td>/brokers/seqid</td> <td> </td> <td> </td> </tr> <tr> <td>/brokers/topics</td> <td> </td> <td> </td> </tr> <tr> <td>/cluster</td> <td> </td> <td>集群信息</td> </tr> <tr> <td>/cluster/id</td> <td>{<br/> “version”: “1”,<br/> “id”: “tsc3VC-yQeeCkti2jdaX-Q”<br/>}</td> <td> </td> </tr> <tr> <td>/config</td> <td> </td> <td>配置相关，如topic或客户端相关的配置</td> </tr> <tr> <td>/config/brokers/<broker_id></broker_id></td> <td>{<br/> “version”: 1,<br/> “config”: {}<br/>}</td> <td> </td> </tr> <tr> <td>/config/changes/config<em>change</em><nums></nums></td> <td>{<br/> “version”: 2,<br/> “entity_path”: “topics/xxxxxx”<br/>}</td> <td>记录所有配置变更</td> </tr> <tr> <td>/config/clients</td> <td> </td> <td> </td> </tr> <tr> <td>/config/topics/__consumer_offsets</td> <td>{<br/> “version”: 1,<br/> “config”:<br/> {<br/> “segment.bytes”: “104857600”,<br/> “compression.type”: “producer”,<br/> “cleanup.policy”: “compact”<br/> }<br/>}</td> <td> </td> </tr> <tr> <td>/config/topics/<topic_name></topic_name></td> <td>{“version”:1,”config”:{}}</td> <td>topic配置</td> </tr> <tr> <td>/config/users</td> <td> </td> <td> </td> </tr> <tr> <td>/consumers</td> <td> </td> <td>消费组信息</td> </tr> <tr> <td>/controller</td> <td>{<br/> “version”: 1,<br/> “brokerid”: 2,<br/> “timestamp”: “1722923238927”<br/>}</td> <td>集群中controller的信息（特殊的broker，负责协调选举等控制任务）</td> </tr> <tr> <td>/controller_epoch</td> <td>37</td> <td>记录epoch，每次选举后增加</td> </tr> <tr> <td>/isr_change_notification</td> <td> </td> <td>临时节点，用于通知ISR中的变更</td> </tr> <tr> <td>/latest_producer_id_block</td> <td>{<br/> “version”: 1,<br/> “broker”: 1,<br/> “block_start”: “54000”,<br/> “block_end”: “54999”<br/>}</td> <td>存储producer的id范围最新状态</td> </tr> <tr> <td>log_dir_event_notification</td> <td> </td> <td>用于触发和管理日志目录变更的通知机制</td> </tr> </tbody> </table>]]></content><author><name></name></author><category term="distributed-systems"/><category term="distributed-systems"/><summary type="html"><![CDATA[从Kafka Paper中感受其设计思想]]></summary></entry><entry><title type="html">Raft论文阅读小记 / RAFT paper reading notes 📝</title><link href="https://ifuryst.github.io/blog/2024/raft/" rel="alternate" type="text/html" title="Raft论文阅读小记 / RAFT paper reading notes 📝"/><published>2024-08-21T12:51:27+00:00</published><updated>2024-08-21T12:51:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/raft</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/raft/"><![CDATA[<p><a href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a></p> <p>建议读一下原Paper</p> <h2 id="背景">背景</h2> <p><code class="language-plaintext highlighter-rouge">RAFT</code>是一个分布式领域内的共识算法（Consensus Algorithm），目的是为了提供一个更加直观易懂（Understandability）、 更易于实现且不丧失相关的强一致性，可以理解就是<code class="language-plaintext highlighter-rouge">PAXOS</code>的通识版</p> <p>因为此前<code class="language-plaintext highlighter-rouge">PAXOS</code>在这个领域占据主导地位，大量的教科书里都是用<code class="language-plaintext highlighter-rouge">PAXOS</code>来教学，初学者有较大的学习成本，并且工程实践方面也比较困难，表现在2点：</p> <ol> <li>理解的难度，再加上理论和实践的差距</li> <li><code class="language-plaintext highlighter-rouge">PAXOS</code>对于很多细节并没有阐述清晰，导致各方在实现的时候就会根据情况去变形，导致最终大家实现的都是有出入的</li> </ol> <p>Conclusion里的这段我觉得能挺清晰的表达出<code class="language-plaintext highlighter-rouge">RAFT</code>对于易理解的追求：</p> <blockquote> <p>Algorithms are often designed with correctness, efficiency, and/or conciseness as the primary goals. Although these are all worthy goals, we believe that understandability is just as important. None of the other goals can be achieved until developers render the algorithm into a practical implementation, which will inevitably deviate from and expand upon the published form. Unless developers have a deep understanding of the algorithm and can create intuitions about it, it will be difficult for them to retain its desirable properties in their implementation.</p> </blockquote> <p>整体就是说，追求正确、效率和简洁明了通常是设计算法里的首要目的，但是<code class="language-plaintext highlighter-rouge">RAFT</code>的作者认为易于理解同样重要。除非深入的理解， 否则在实现或者在不同形式的传播中，很难一直保持其原有的设计思想或理念，也就是咱们前面说到的，实现中要根据情况、经验和认知去决定实现方式， 不可避免的结果就是会导致很多“版本”的流通</p> <h2 id="设计理念">设计理念</h2> <p><code class="language-plaintext highlighter-rouge">RAFT</code>借鉴了现实社会中的领导选举机制，还挺方便理解。从全局的角度看，整体遵循了这么几个点：</p> <ol> <li>只有三种角色：Leader（主，领导者）、Candidate（候选者）、Follower（跟随者）</li> <li>任期制：确保节点不可用时（尤其Leader）能快速感知和切换</li> <li>所有的操作只能在Leader上进行（需要注意，这种情况下性能层面会有一定问题，因此在某些应用场景还是需要结合一些其他缓存系统来保障高效的读写，这就是架构设计中需要注意的，没有银弹，一切都是取舍Tradeoff，当然要做tradeoff之前你是需要对涉及到的技术、系统的设计理念和应用场景有一定的认知，才能做出正确的判断）</li> <li>追加日志，日志从Leader复制到其他Follower</li> <li>安全性：日志复制需要经过一致性检查，大多数节点确认才可提交</li> </ol> <p>其他的就是基于这些点下沉的一些细节，比如：</p> <ul> <li>怎么选举</li> <li>角色如何切换</li> <li>怎么防止切换时日志被新主覆盖</li> <li>节点故障的具体处理细节</li> <li>如何保持心跳</li> <li>如何处理在相同下标下的不同数据</li> </ul> <h2 id="选举">选举</h2> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Left: Electoral Process, Right: RequestVote RPC </div> <ol> <li>刚启动，所有节点都是Follower（或者Leader没了，剩余的都是Follower）</li> <li>发现没有来自Leader的心跳同步包（Leader发送的心跳是跟着AppendEntriesRPC请求一起的，哪怕没有数据也可以发空payload代表这个请求只用于心跳用途），等待任期超时（每个节点的超时时间都是不同的，随机的，意图是这样能有效避免选票分散在多个同时发起选举的候选人身上）</li> <li>某些节点超时了，触发选举，将自己从Follower提升到Candidate，发送投票请求（RequestVote RPC）给所有节点（会携带上任期号term和最新的日志下标lastLogIndex, lastLogTerm）</li> <li>节点收到投票请求，会和本身的当前任期对比，如果自己所处的任期大于对方的，或者自己的日志比对方更多，拒绝投给对方，否则就投票给对方（同节点可能会收到多个投票请求，也是基于这个逻辑来确认投给谁）</li> <li>最终票数多的成为Leader（也有可能票数一样导致没有Leader产生，就会等下一任期到来再选举一波），开始定期发心跳维持自己的地位（某个节点在超时时间内收到Leader的心跳会重启超时等待，直到没收到就会回到Step 2.开启新的选举），此时其他节点全部退回Follower状态</li> </ol> <h2 id="日志复制">日志复制</h2> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Left: State, Right: AppendEntries RPC </div> <p>每个节点自身都维持了一个状态机（State）在内存，代表目前的数据情况，只有被确认提交的数据会进到这里，收到但还没确认的不会</p> <p>日志追加的方式，通过AppendEntriesRPC请求同步给其他的节点，在大多数的节点确认后，会进行提交， 这样能有效确保Leader切换后数据不会丢失（拥有的日志越多的节点约有可能成为下一任Leader）</p> <p>整体流程如下：</p> <ol> <li>收到写数据请求，操作附加到自己的日志中（此时还没提交生效）</li> <li>发送日志给其他节点（发AppendEntriesRPC请求），信息里面会包含一些诸如任期号、LeaderID，日志条目和下标等信息</li> <li>Follower节点收到后，检查自己的日志条目情况，如果匹配就追加最新的，不匹配的话拒绝（Leader给的前面的Log的任期不同之类的情况）</li> <li>Leader收到超过半数节点的成功响应后，确认已经传播到多数节点了，该日志条目被标记为提交（commited），应用条目到自己的状态机中（下一次AppendEntriesRPC就会告知Follower已经提交到这个位置，Follower也可以跟着提交到这个下标位置的Log）</li> <li>Leader响应客户端</li> </ol> <p>在此期间，Step 3.会有个分叉逻辑，就是Leader需要补发Follower缺失的Log， Log下标会往前推直到这个Follower最后的Log位置（此时会借助一些任期号来加快定位到需要补的日志的开头）</p> <h2 id="安全性">安全性</h2> <p><code class="language-plaintext highlighter-rouge">RAFT</code>通过任期号、多数投票选举、日志的一些机制保障了安全性，以下列举几个点：</p> <ul> <li>多数投票选举机制和任期号机制，防止出现脑裂（No Split-Brain）</li> <li>Leader包含所有已提交条目（Leader Completeness Property），统一负责读写，包括线性一致性读（Linearizable reads）</li> <li>只有Follower的日志可以被覆盖，Leader的日志只能不断追加，不可再覆盖旧的</li> <li>多数确认提交，确保多数确认的情况下才会提交</li> </ul> <h2 id="写在最后">写在最后</h2> <p>整体过了一下<code class="language-plaintext highlighter-rouge">RAFT</code>的一些设计理念，从paper里的一些表述中能很明确的感受到作者的意图和想法，尽可能阅读最一手的资料是追求有效信息的好方法， 也可以避免信息传播过程中产生的变形（不过也有利弊，有些人会有更加翔实的分析和剖析，就像这篇文章一样也是二手信息）</p> <p>值得一提的是，在paper里一句带过的Leader租约（Lease）机制，在实际应用中也是一个挺重要的点， 比如Consul和Etcd都实现这个机制，可以增加读的性能（风险取决于节点间的时钟差异程度和可接受的时钟漂移范围）</p>]]></content><author><name></name></author><category term="distributed-systems"/><category term="distributed-systems"/><summary type="html"><![CDATA[从Raft paper中感受其设计思想]]></summary></entry></feed>
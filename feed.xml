<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ifuryst.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ifuryst.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-08-21T15:33:57+00:00</updated><id>https://ifuryst.github.io/feed.xml</id><title type="html">ifuryst</title><subtitle>📝 &amp; 💭 </subtitle><entry><title type="html">zsh nice 5 🧐</title><link href="https://ifuryst.github.io/blog/2024/zsh-nice-5/" rel="alternate" type="text/html" title="zsh nice 5 🧐"/><published>2024-08-07T12:51:27+00:00</published><updated>2024-08-07T12:51:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/zsh-nice-5</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/zsh-nice-5/"><![CDATA[<blockquote> <p>The English Version is <a href="https://medium.com/@ifuryst./zsh-nice-5-f520a70d0f90">here</a></p> </blockquote> <p>今天在排查一个服务吞吐量上不去的问题，在做压力测试，期间刚好在观测CPU使用率，系统是32c的。 除了关注进程的CPU消耗情况，我还会关注每个核心的使用率，确保不会出现核心利用率不均衡（之前在NUMA Node时因为大量网卡软中断出现过，所以现在习惯性会关注一下） ， 一开始一切都蛮正常的，类似这样：</p> <div class="row mt-3"> <div class="col-12 col-md-8 col-lg-6 col-xl-6 col-xxl-6 mt-0 mb-0 mx-auto"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-07-zsh-nice-5/normal_cpu_usage.2024-08-07_17-49-16-480.webp 480w,/assets/img/2024-08-07-zsh-nice-5/normal_cpu_usage.2024-08-07_17-49-16-800.webp 800w,/assets/img/2024-08-07-zsh-nice-5/normal_cpu_usage.2024-08-07_17-49-16-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-07-zsh-nice-5/normal_cpu_usage.2024-08-07_17-49-16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Normal CPU Usage </div> <p>可以看到，进程使用了28c，约为87%的使用率。整体其实已经跑了挺满的，在单核上也可以观测到us都蛮高且相对均衡（77%~90%）</p> <blockquote> <h5 id="tip">TIP</h5> <p class="block-tip">top里是按照绝对值计算百分比的，因此不是传统的0-100%的认知，比如我32c，实际上最大是跑到3200%</p> </blockquote> <div class="row mt-3"> <div class="col-12 col-md-8 col-lg-6 col-xl-6 col-xxl-6 mt-0 mb-0 mx-auto"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-07-zsh-nice-5/abnormal_cpu_usage.2024-08-07_17-51-01-480.webp 480w,/assets/img/2024-08-07-zsh-nice-5/abnormal_cpu_usage.2024-08-07_17-51-01-800.webp 800w,/assets/img/2024-08-07-zsh-nice-5/abnormal_cpu_usage.2024-08-07_17-51-01-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-07-zsh-nice-5/abnormal_cpu_usage.2024-08-07_17-51-01.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Abnormal CPU Usage </div> <p>在经过几次调整测试的过程中，突然之间，我留意到单核的us都接近0了，但是进程级别的使用率看起来和之前保持相似的使用率，此时脑子过了好几个想法：</p> <ul> <li>是不是top的显示有问题？</li> <li>top发生某种奇怪的错误统计？</li> </ul> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-07-zsh-nice-5/grafana_total_cpu_usage.2024-08-07_17-59-21-480.webp 480w,/assets/img/2024-08-07-zsh-nice-5/grafana_total_cpu_usage.2024-08-07_17-59-21-800.webp 800w,/assets/img/2024-08-07-zsh-nice-5/grafana_total_cpu_usage.2024-08-07_17-59-21-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-07-zsh-nice-5/grafana_total_cpu_usage.2024-08-07_17-59-21.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-07-zsh-nice-5/grafana_core_cpu_usage.2024-08-07_17-59-48-480.webp 480w,/assets/img/2024-08-07-zsh-nice-5/grafana_core_cpu_usage.2024-08-07_17-59-48-800.webp 800w,/assets/img/2024-08-07-zsh-nice-5/grafana_core_cpu_usage.2024-08-07_17-59-48-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-07-zsh-nice-5/grafana_core_cpu_usage.2024-08-07_17-59-48.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Grafana CPU Usage: Total Left, Core Right </div> <p>然后我马上打开<code class="language-plaintext highlighter-rouge">Grafana</code>查看了机器层面的自监控，在<code class="language-plaintext highlighter-rouge">Grafana</code>上查看总体CPU使用率和分核使用率都是在高位，符合预期，略奇怪（此时仍然不知道自己粗心没留意到ni）</p> <p>结合前面的想法，我找了设备运维大佬，请教了问题，然后他一下指出ni很高，不太对，还指明正常我们的设备不会调整进程的nice。 这个时候我才恍然大悟，哦，确实ni列的值都很高呀，然后我开始从乡村土路开回了高速</p> <p>首先明确一下<a href="https://en.wikipedia.org/wiki/Nice_(Unix)">nice</a>的定义，nice越小优先级越高（范围从-20 ~ 19 or -20 ~ 20） 系统级别的正常-20，用户态进程是0，我看了一下我的进程是5🤔，what’s going on? 直到这里已经能解释清楚，为什么ni那么高了，因为进程的<code class="language-plaintext highlighter-rouge">nice=5</code>， 被认为是较低优先级的进程，同等条件下比0或者-20更加小的机会被CPU调度执行，但是因为我的进程在压测，进程过于强势，吃掉了80+%的CPU时间片， 此时就单核心的ni列代表就是CPU被低优先级的进程占用的百分比，其实这种情况下是符合预期的，也就是我们认为的单核使用率=us+ni，在这种场景下， 没有任何问题。</p> <p>回过头来，问题在于，为什么进程变成了<code class="language-plaintext highlighter-rouge">ni 5</code>？什么时候开始的？为什么？</p> <p>于是开始回溯，开始挖掘，因为压测过程中会调整各类参数，甚至也会调优一下代码，所以还是有比较多的变量，好在我能明确是那次变化出现的， 不过挖掘了半天没再出现，直到某刻突然灵光一闪，不会是<code class="language-plaintext highlighter-rouge">bg job</code>吧？因为要调整启动参数，有时候为了快速切换我会直接kill掉服务然后用类似<code class="language-plaintext highlighter-rouge">commd &amp;</code>的方式直接手动拉一下， 然后我试了一下，bingo，就是你了，然后我就写了一个shell进一步确认了一下</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>

<span class="nb">sleep </span>333<span class="p">;</span>
</code></pre></div></div> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-07-zsh-nice-5/bg_job_in_zsh_bash.2024-08-07_18-05-18-480.webp 480w,/assets/img/2024-08-07-zsh-nice-5/bg_job_in_zsh_bash.2024-08-07_18-05-18-800.webp 800w,/assets/img/2024-08-07-zsh-nice-5/bg_job_in_zsh_bash.2024-08-07_18-05-18-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-07-zsh-nice-5/bg_job_in_zsh_bash.2024-08-07_18-05-18.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> bg job in zsh &amp; bash </div> <p>确实是，通过这种方式启动的，会导致nice被打成5，然后我就开始在网上找资料，并且也问了ChatGPT，但是并没有任何相关的信息明确表示<code class="language-plaintext highlighter-rouge">bg job</code>会将nice设成<code class="language-plaintext highlighter-rouge">5</code>， 并且有些地方明确表示除非主动设置否则不会改变进程的nice值，此时我灵光一想，从zsh切到bash，测了一下，emmmm，确实不会改变nice，至少在bash下不会， 问题面进一步缩小了，问题出在zsh身上，继续查资料问AI，依然没有明确的结果，我还进一步检查了包括.zshrc在内相关的配置文件里也没有任何nice相关的设置，很疑惑</p> <p>过了一会我放弃在网上搜索结果了，我开始找<a href="https://zsh.sourceforge.io/Arc/git.html">zsh的源码</a>，当我把源码clone下来，我开始翻看源码， C写的，我有两个线索，一个是<code class="language-plaintext highlighter-rouge">nice=5</code>，一个是<code class="language-plaintext highlighter-rouge">bg job(&amp;)</code>，开始围绕这两个去针对性挖掘就好了，在这里我依然还是背靠大山，ChatGPT一下就帮我缩小范围到某几个文件上了，分别是</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	•	Src/parse.c：包含 zsh 的语法解析器代码。
	•	Src/exec.c：包含命令执行相关的代码。
	•	Src/jobs.c：处理作业控制和后台进程的代码。
</code></pre></div></div> <p>我在<code class="language-plaintext highlighter-rouge">jobs.c</code>找到了<code class="language-plaintext highlighter-rouge">spawnjob</code>这个函数，但是这个文件没有涉及nice的调整，继续翻看了<code class="language-plaintext highlighter-rouge">exec.c</code>，在<code class="language-plaintext highlighter-rouge">execcmd_fork</code>这个函数内部，看到了目标代码</p> <ul id="execcmd-fork" class="tab" data-tab="b4500809-2f34-44e2-b28f-533d09e0d190" data-name="execcmd-fork"> <li class="active" id="execcmd-fork-newest-version"> <a href="#">newest version </a> </li> <li id="execcmd-fork-oldest-version"> <a href="#">oldest version </a> </li> </ul> <ul class="tab-content" id="b4500809-2f34-44e2-b28f-533d09e0d190" data-name="execcmd-fork"> <li class="active"> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/**/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">execcmd_fork</span><span class="p">(</span><span class="n">Estate</span> <span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="n">Wordcode</span> <span class="n">varspc</span><span class="p">,</span>
	     <span class="n">LinkList</span> <span class="o">*</span><span class="n">filelistp</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">text</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oautocont</span><span class="p">,</span>
	     <span class="kt">int</span> <span class="n">close_if_forked</span><span class="p">)</span>
<span class="p">{</span>
<span class="c1">// ...</span>
<span class="cp">#ifdef HAVE_NICE
</span>    <span class="cm">/* Check if we should run background jobs at a lower priority. */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">how</span> <span class="o">&amp;</span> <span class="n">Z_ASYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isset</span><span class="p">(</span><span class="n">BGNICE</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nice</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">errno</span><span class="p">)</span>
	    <span class="n">zwarn</span><span class="p">(</span><span class="s">"nice(5) failed: %e"</span><span class="p">,</span> <span class="n">errno</span><span class="p">);</span>
    <span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_NICE */</span><span class="cp">
</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> </li> <li> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef HAVE_NICE
</span>	<span class="cm">/* Check if we should run background jobs at a lower priority. */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">how</span> <span class="o">&amp;</span> <span class="n">Z_ASYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">isset</span><span class="p">(</span><span class="n">BGNICE</span><span class="p">))</span>
	    <span class="n">nice</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* HAVE_NICE */</span><span class="cp">
</span></code></pre></div></div> </li> </ul> <p>可以看到这个条件编译（即在支持nice的系统上才会调用）内部包含了判断：当是异步作业的时候，并且<code class="language-plaintext highlighter-rouge">BGNICE</code>设置的话，就会把<code class="language-plaintext highlighter-rouge">nice设置5</code>， 翻看了一下git历史，从<code class="language-plaintext highlighter-rouge">1999年4月16日</code>最初的版本就已经带上了这个核心逻辑了，只是后来针对<code class="language-plaintext highlighter-rouge">cmd fork</code>和相关的错误捕获做了几次修订</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-07-zsh-nice-5/git_history.2024-08-07_18-25-28-480.webp 480w,/assets/img/2024-08-07-zsh-nice-5/git_history.2024-08-07_18-25-28-800.webp 800w,/assets/img/2024-08-07-zsh-nice-5/git_history.2024-08-07_18-25-28-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-07-zsh-nice-5/git_history.2024-08-07_18-25-28.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Git History </div> <p>所以我们可以明确从最开始zsh就已经明确后台执行的任务优先级不会比前台的任务高，也就一直遗留至今了，至于历史原因，我是没找到任何相关的资料文献， 我看到最初<code class="language-plaintext highlighter-rouge">Inital reversion</code>是<code class="language-plaintext highlighter-rouge">Tanaka Akira</code>提交的，我写了一封邮件给他，希望能了解一下历史原因和背景。但是可惜的是，他的邮箱已经不再使用了， 被退信了。</p> <p>其实在此基础上其实还可以继续挖一下how, Z_ASYNC, BGNICE的来源，在哪些地方被更改设置了，甚至进一步再回顾一下CPU调度策略，尤其结合优先级来测一下， 但是最近有点忙，社区里还有几个PR需要处理。whatever, casual tech just for casual :)</p> <p>只是好奇心作祟下的一次探索 💀</p>]]></content><author><name></name></author><category term="casual-tech"/><category term="linux"/><summary type="html"><![CDATA[How the nice value disturb the observation for CPU usage]]></summary></entry><entry><title type="html">RAFT paper reading notes 📝</title><link href="https://ifuryst.github.io/blog/2024/raft/" rel="alternate" type="text/html" title="RAFT paper reading notes 📝"/><published>2024-08-07T12:51:27+00:00</published><updated>2024-08-07T12:51:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/raft</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/raft/"><![CDATA[<h2 id="背景">背景</h2> <p><code class="language-plaintext highlighter-rouge">RAFT</code>是一个分布式领域内的共识算法（Consensus Algorithm），目的是为了提供一个更加直观易懂（Understandability）、 更易于实现且不丧失相关的强一致性，可以理解就是<code class="language-plaintext highlighter-rouge">PAXOS</code>的通识版</p> <p>因为此前<code class="language-plaintext highlighter-rouge">PAXOS</code>在这个领域占据主导地位，大量的教科书里都是用<code class="language-plaintext highlighter-rouge">PAXOS</code>来教学，初学者有较大的学习成本，并且工程实践方面也比较困难，表现在2点：</p> <ol> <li>理解的难度，再加上理论和实践的差距</li> <li><code class="language-plaintext highlighter-rouge">PAXOS</code>对于很多细节并没有阐述清晰，导致各方在实现的时候就会根据情况去变形，导致最终大家实现的都是有出入的</li> </ol> <p>Conclusion里的这段我觉得能挺清晰的表达出<code class="language-plaintext highlighter-rouge">RAFT</code>对于易理解的追求：</p> <blockquote> <p>Algorithms are often designed with correctness, efficiency, and/or conciseness as the primary goals. Although these are all worthy goals, we believe that understandability is just as important. None of the other goals can be achieved until developers render the algorithm into a practical implementation, which will inevitably deviate from and expand upon the published form. Unless developers have a deep understanding of the algorithm and can create intuitions about it, it will be difficult for them to retain its desirable properties in their implementation.</p> </blockquote> <p>整体就是说，追求正确、效率和简洁明了通常是设计算法里的首要目的，但是<code class="language-plaintext highlighter-rouge">RAFT</code>的作者认为易于理解同样重要。除非深入的理解， 否则在实现或者在不同形式的传播中，很难一直保持其原有的设计思想或理念，也就是咱们前面说到的，实现中要根据情况、经验和认知去决定实现方式， 不可避免的结果就是会导致很多“版本”的流通</p> <h2 id="设计理念">设计理念</h2> <p><code class="language-plaintext highlighter-rouge">RAFT</code>借鉴了现实社会中的领导选举机制，还挺方便理解。从全局的角度看，整体遵循了这么几个点：</p> <ol> <li>只有三种角色：Leader（主，领导者）、Candidate（候选者）、Follower（跟随者）</li> <li>任期制：确保节点不可用时（尤其Leader）能快速感知和切换</li> <li>所有的操作只能在Leader上进行（需要注意，这种情况下性能层面会有一定问题，因此在某些应用场景还是需要结合一些其他缓存系统来保障高效的读写，这就是架构设计中需要注意的，没有银弹，一切都是取舍Tradeoff，当然要做tradeoff之前你是需要对涉及到的技术、系统的设计理念和应用场景有一定的认知，才能做出正确的判断）</li> <li>追加日志，日志从Leader复制到其他Follower</li> <li>安全性：日志复制需要经过一致性检查，大多数节点确认才可提交</li> </ol> <p>其他的就是基于这些点下沉的一些细节，比如：</p> <ul> <li>怎么选举</li> <li>角色如何切换</li> <li>怎么防止切换时日志被新主覆盖</li> <li>节点故障的具体处理细节</li> <li>如何保持心跳</li> <li>如何处理在相同下标下的不同数据</li> </ul> <h2 id="选举">选举</h2> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/electoral_process.2024-08-21_23-26-19.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/requestvote_rpc.2024-08-21_23-26-35.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Left: Electoral Process, Right: RequestVote RPC </div> <ol> <li>刚启动，所有节点都是Follower（或者Leader没了，剩余的都是Follower）</li> <li>发现没有来自Leader的心跳同步包（Leader发送的心跳是跟着AppendEntriesRPC请求一起的，哪怕没有数据也可以发空payload代表这个请求只用于心跳用途），等待任期超时（每个节点的超时时间都是不同的，随机的，意图是这样能有效避免选票分散在多个同时发起选举的候选人身上）</li> <li>某些节点超时了，触发选举，将自己从Follower提升到Candidate，发送投票请求（RequestVote RPC）给所有节点（会携带上任期号term和最新的日志下标lastLogIndex, lastLogTerm）</li> <li>节点收到投票请求，会和本身的当前任期对比，如果自己所处的任期大于对方的，或者自己的日志比对方更多，拒绝投给对方，否则就投票给对方（同节点可能会收到多个投票请求，也是基于这个逻辑来确认投给谁）</li> <li>最终票数多的成为Leader（也有可能票数一样导致没有Leader产生，就会等下一任期到来再选举一波），开始定期发心跳维持自己的地位（某个节点在超时时间内收到Leader的心跳会重启超时等待，直到没收到就会回到Step 2.开启新的选举），此时其他节点全部退回Follower状态</li> </ol> <h2 id="日志复制">日志复制</h2> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/state.2024-08-21_23-26-51.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04-480.webp 480w,/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04-800.webp 800w,/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-08-21-raft-paper-reading-notes/appendentries_rpc.2024-08-21_23-27-04.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Left: State, Right: AppendEntries RPC </div> <p>每个节点自身都维持了一个状态机（State）在内存，代表目前的数据情况，只有被确认提交的数据会进到这里，收到但还没确认的不会</p> <p>日志追加的方式，通过AppendEntriesRPC请求同步给其他的节点，在大多数的节点确认后，会进行提交， 这样能有效确保Leader切换后数据不会丢失（拥有的日志越多的节点约有可能成为下一任Leader）</p> <p>整体流程如下：</p> <ol> <li>收到写数据请求，操作附加到自己的日志中（此时还没提交生效）</li> <li>发送日志给其他节点（发AppendEntriesRPC请求），信息里面会包含一些诸如任期号、LeaderID，日志条目和下标等信息</li> <li>Follower节点收到后，检查自己的日志条目情况，如果匹配就追加最新的，不匹配的话拒绝（Leader给的前面的Log的任期不同之类的情况）</li> <li>Leader收到超过半数节点的成功响应后，确认已经传播到多数节点了，该日志条目被标记为提交（commited），应用条目到自己的状态机中（下一次AppendEntriesRPC就会告知Follower已经提交到这个位置，Follower也可以跟着提交到这个下标位置的Log）</li> <li>Leader响应客户端</li> </ol> <p>在此期间，Step 3.会有个分叉逻辑，就是Leader需要补发Follower缺失的Log， Log下标会往前推直到这个Follower最后的Log位置（此时会借助一些任期号来加快定位到需要补的日志的开头）</p> <h2 id="安全性">安全性</h2> <p><code class="language-plaintext highlighter-rouge">RAFT</code>通过任期号、多数投票选举、日志的一些机制保障了安全性，以下列举几个点：</p> <ul> <li>多数投票选举机制和任期号机制，防止出现脑裂（No Split-Brain）</li> <li>Leader包含所有已提交条目（Leader Completeness Property），统一负责读写，包括线性一致性读（Linearizable reads）</li> <li>只有Follower的日志可以被覆盖，Leader的日志只能不断追加，不可再覆盖旧的</li> <li>多数确认提交，确保多数确认的情况下才会提交</li> </ul> <h2 id="写在最后">写在最后</h2> <p>整体过了一下<code class="language-plaintext highlighter-rouge">RAFT</code>的一些设计理念，从paper里的一些表述中能很明确的感受到作者的意图和想法，尽可能阅读最一手的资料是追求有效信息的好方法， 也可以避免信息传播过程中产生的变形（不过也有利弊，有些人会有更加翔实的分析和剖析，就像这篇文章一样也是二手信息）</p> <p>值得一提的是，在paper里一句带过的Leader租约（Lease）机制，在实际应用中也是一个挺重要的点， 比如Consul和Etcd都实现这个机制，可以增加读的性能（风险取决于节点间的时钟差异程度和可接受的时钟漂移范围）</p>]]></content><author><name></name></author><category term="distributed-systems"/><category term="distributed-systems"/><summary type="html"><![CDATA[从Raft paper中感受其设计思想]]></summary></entry><entry><title type="html">zsh nice 5 🧐. How the nice value disturb the… | by ifuryst | Aug, 2024 | Medium</title><link href="https://ifuryst.github.io/blog/2024/zsh-nice-5-how-the-nice-value-disturb-the-by-ifuryst-aug-2024-medium/" rel="alternate" type="text/html" title="zsh nice 5 🧐. How the nice value disturb the… | by ifuryst | Aug, 2024 | Medium"/><published>2024-08-07T00:00:00+00:00</published><updated>2024-08-07T00:00:00+00:00</updated><id>https://ifuryst.github.io/blog/2024/zsh-nice-5--how-the-nice-value-disturb-the--by-ifuryst--aug-2024--medium</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/zsh-nice-5-how-the-nice-value-disturb-the-by-ifuryst-aug-2024-medium/"><![CDATA[]]></content><author><name></name></author><category term="linux"/><category term="casual-tech"/><summary type="html"><![CDATA[Today, I was troubleshooting an issue with a service’s throughput during a stress test. While observing the CPU usage, I paid attention not only to the process’s CPU consumption but also to the usage…]]></summary></entry><entry><title type="html">TCP congestion control. Statement!!! | by ifuryst | Medium</title><link href="https://ifuryst.github.io/blog/2024/tcp-congestion-control-statement-by-ifuryst-medium/" rel="alternate" type="text/html" title="TCP congestion control. Statement!!! | by ifuryst | Medium"/><published>2024-03-12T00:00:00+00:00</published><updated>2024-03-12T00:00:00+00:00</updated><id>https://ifuryst.github.io/blog/2024/tcp-congestion-control-statement--by-ifuryst--medium</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/tcp-congestion-control-statement-by-ifuryst-medium/"><![CDATA[]]></content><author><name></name></author><category term="TCP"/><category term="networking"/><summary type="html"><![CDATA[I am sharing a draft article from a field I no longer focus on but believe the insights within are too valuable not to share. Please note, this manuscript is presented as-is :) All of these…]]></summary></entry></feed>
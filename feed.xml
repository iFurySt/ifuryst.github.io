<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="https://ifuryst.github.io/feed.xml" rel="self" type="application/atom+xml"/><link href="https://ifuryst.github.io/" rel="alternate" type="text/html" hreflang="en"/><updated>2024-11-25T14:23:59+00:00</updated><id>https://ifuryst.github.io/feed.xml</id><title type="html">ifuryst</title><subtitle>📝 &amp; 💭 </subtitle><entry><title type="html">15s→1s慢查询优化小记</title><link href="https://ifuryst.github.io/blog/2024/optimizing-slow-queries-from-15s-to-1s/" rel="alternate" type="text/html" title="15s→1s慢查询优化小记"/><published>2024-11-22T13:41:27+00:00</published><updated>2024-11-22T13:41:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/optimizing-slow-queries-from-15s-to-1s</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/optimizing-slow-queries-from-15s-to-1s/"><![CDATA[<p>SQL慢查询是老生常谈的问题了，似乎好像不会做点优化都不行。慢查询优化其实有很多手段，并且也根据应用场景和需求而异，我觉得比较重要的还是了解底层原理，这样上层应用层怎么变化都能比较快的找到优化的点。借着这个机会小谈一下SQL优化中的一些过程和想法。</p> <p>另外有点标题党了，我觉得能有较大收益的情况很有可能是因为底子太差了，就像这次帮人看的这个项目，才能简单的做出这么大的优化。不过世界是个草台班子，到哪都可能遇到因肝需求而留下的技术债，这种地方如果没有做好顶层设计和代码质量把控的话，极其容易出现这个问题，堆需求，然后出问题再来反向优化解决的情况。</p> <h2 id="准备阶段">准备阶段</h2> <p>开始处理慢查询问题前，有几个东西需要提前准备好：</p> <ol> <li>具体产生位置</li> <li>数据组装</li> <li>定基准点</li> </ol> <h3 id="具体产生位置">具体产生位置</h3> <p>这里主要是定位问题产生点，很多时候我们有慢查询的统计SQL，就能进一步根据语句到代码反差，这部分通常比较容易的就可以做好定位。</p> <p>通常我们会基于产生位置反向摸排，确定调用方，这样可以进一步确定影响范围，减少后续改动对外部的影响</p> <h3 id="数据组装">数据组装</h3> <p>需要进行各类数据或者参数的组装，用于复现实际问题。</p> <p>通常情况下，我们希望最大化负载，也就是以业务范围内较糟糕的情况来组装数据进行复现，能有压测条件是更好的。这样我们可以最大化各个关键环节和节点的消耗情况，可以进一步研判优化位置</p> <h3 id="定基准点">定基准点</h3> <p>我们通常会以前面确定的较坏的情况做基准，后续以此为基准去做优化，这样能给我们优化提供方向和结果的量化。另外有些情况下我们还会有明确的目标阈值指导我们持续优化到目标</p> <h2 id="优化过程">优化过程</h2> <p>对于慢查询的优化有非常多的方法，这里我们主要沿着此次遇到的问题提取关键优化点做一定的分析和发散。</p> <p>因为问题比较明确，这边我们在组装完所需的配套数据和参数之后，就直接到关键的SQL部分去做分阶段的打印，因为涉及的SQL操作比较多，所以我们希望能明确各阶段的消耗。这边我在代码里一些关键点埋了一下打印。跑测后，我们得到分阶段的消耗统计</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stage 1: <span class="o">===&gt;</span> 428ms
Stage 2: <span class="o">===&gt;</span> 138ms
Stage 3: <span class="o">===&gt;</span> 7ms
Stage 4: <span class="o">===&gt;</span> 617ms
Stage 5: <span class="o">===&gt;</span> 13898ms
</code></pre></div></div> <p>此时我们可以明确问题出现阶段5，消耗了13s的查询时间，我们先着重处理这个位置</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_code.2024-11-22_15-51-28-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_code.2024-11-22_15-51-28-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_code.2024-11-22_15-51-28-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_code.2024-11-22_15-51-28.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> 原始代码 </div> <p>首先观察到有3个数据库查询的调用，后两个还好点，通过IN的方式走，第一个是大量LIKE的方式，我们优先解决这个，这里就产生了第一个优化点：LIKE的使用</p> <h3 id="like的使用">LIKE的使用</h3> <p>通常情况下我们会尽量不使用或者减少使用LIKE子句，MySQL中LIKE只有在前缀匹配的时候才会走索引，也就是</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 精准匹配或者字符串开头的，可以走索引</span>
SELECT <span class="k">*</span> FROM table WHERE column LIKE <span class="s1">'abc%'</span><span class="p">;</span>
SELECT <span class="k">*</span> FROM table WHERE column LIKE <span class="s1">'abc'</span><span class="p">;</span>
<span class="c"># 通配符开头的，不走索引</span>
SELECT <span class="k">*</span> FROM table WHERE column LIKE <span class="s1">'%abc'</span><span class="p">;</span>
SELECT <span class="k">*</span> FROM table WHERE column LIKE <span class="s1">'%abc%'</span><span class="p">;</span>
</code></pre></div></div> <p>对于大数据集来说，这种模糊匹配性能很低，尽可能应该避免，或者采用ES之类的专用全文搜索引擎。</p> <p>通过对外部所有调用方的入参情况确认，我们可以分析出这里并不需要使用LIKE，因为传入的orgIdList其实已经包含了父子orgId的完整合集了，因此我们直接去掉LIKE部分的检索</p> <p>我们跑测一下，可以看到，已经从13s将为3s了</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stage 1: <span class="o">===&gt;</span> 279ms
Stage 2: <span class="o">===&gt;</span> 160ms
Stage 3: <span class="o">===&gt;</span> 2ms
Stage 4: <span class="o">===&gt;</span> 601ms
Stage 5: <span class="o">===&gt;</span> 3202ms
</code></pre></div></div> <p>此时我们进一步来看看剩下的两个查询操作，可以看到取出来的数据只是期望得到其中某一列的数据，这种情况我们就来到了第二个优化点：只查询必要的列</p> <h3 id="只查询必要的列">只查询必要的列</h3> <p>尤其对于一些数据量大，或者列多的大宽表来说，如果能显式指定列的话，可以提升查询和数据返回过程中的消耗，这边我们收敛一下，并且把代码结构简单调整一下使得代码更加直观</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/specify_cols.2024-11-22_15-57-36-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/specify_cols.2024-11-22_15-57-36-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/specify_cols.2024-11-22_15-57-36-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/specify_cols.2024-11-22_15-57-36.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> 指定列查询 </div> <p>这边我们显式指定了<code class="language-plaintext highlighter-rouge">.select(XXXRel::getOrgPersonId)</code> 和<code class="language-plaintext highlighter-rouge">.select(XXXUser::getAccountId)</code> ，这样SELECT语句只会查询该列</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Stage 1: <span class="o">===&gt;</span> 260ms
Stage 2: <span class="o">===&gt;</span> 140ms
Stage 3: <span class="o">===&gt;</span> 2ms
Stage 4: <span class="o">===&gt;</span> 614ms
Stage 5: <span class="o">===&gt;</span> 1635ms
</code></pre></div></div> <p>跑测后可以看到，这个环节已经被优化到1.6s了</p> <p>此时从代码层面我们已经看不出太多的优化点了，但是此时我们还是可以深挖一下具体的SQL，因为以我们的经验来说，两个SELECT … IN查询不至于需要1.6s，况且数据集也没有达到大几百万或者千万级别，所以我们有理由猜测可能在SQL层面还存在什么问题，我们进一步挖一下</p> <h3 id="sql分析">SQL分析</h3> <p>这边我们拉出两条语句</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">org_person_id</span> <span class="k">FROM</span> <span class="n">db_a</span><span class="p">.</span><span class="n">xxx_rel</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">status_cd</span> <span class="o">=</span> <span class="s1">'1'</span> <span class="k">AND</span> <span class="n">org_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="p">...,</span> <span class="mi">11</span><span class="p">))</span>

<span class="k">SELECT</span> <span class="n">account_id</span> <span class="k">FROM</span> <span class="n">db_b</span><span class="p">.</span><span class="n">xxx_user</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">status_cd</span> <span class="o">=</span> <span class="s1">'1'</span> <span class="k">AND</span> <span class="n">tenant_id</span> <span class="o">=</span> <span class="s1">'abc123'</span> <span class="k">AND</span> <span class="n">org_user_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="p">...,</span> <span class="mi">9</span><span class="p">))</span>
</code></pre></div></div> <p>这里内容过长，我裁剪了大部分的ID，主要结构就是这样，IN了大量的ID，我们用<code class="language-plaintext highlighter-rouge">EXPLAIN</code>来分析一下语句的执行计划（Execution Plan），虽然不是实际的执行，但是通过预测执行计划的分析，可以帮助我们理解查询性能并发现优化点</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="n">org_person_id</span> <span class="k">FROM</span> <span class="n">db_a</span><span class="p">.</span><span class="n">xxx_rel</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">status_cd</span> <span class="o">=</span> <span class="s1">'1'</span> <span class="k">AND</span> <span class="n">org_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="p">...,</span> <span class="mi">11</span><span class="p">))</span>

<span class="k">EXPLAIN</span> <span class="k">SELECT</span> <span class="n">account_id</span> <span class="k">FROM</span> <span class="n">db_b</span><span class="p">.</span><span class="n">xxx_user</span> <span class="k">WHERE</span> <span class="p">(</span><span class="n">status_cd</span> <span class="o">=</span> <span class="s1">'1'</span> <span class="k">AND</span> <span class="n">tenant_id</span> <span class="o">=</span> <span class="s1">'abc123'</span> <span class="k">AND</span> <span class="n">org_user_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="p">...,</span> <span class="mi">9</span><span class="p">))</span>
</code></pre></div></div> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_ref_query.2024-11-19_20-03-55-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_ref_query.2024-11-19_20-03-55-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_ref_query.2024-11-19_20-03-55-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_ref_query.2024-11-19_20-03-55.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_all_query.2024-11-19_20-04-14-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_all_query.2024-11-19_20-04-14-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_all_query.2024-11-19_20-04-14-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/origin_all_query.2024-11-19_20-04-14.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> 原始查询走索引情况 </div> <p>对应的列可以参考官方的<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html">文档释义</a>：</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/explain_output_cols.2024-11-19_20-03-06-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/explain_output_cols.2024-11-19_20-03-06-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/explain_output_cols.2024-11-19_20-03-06-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/explain_output_cols.2024-11-19_20-03-06.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> EXPLAIN列含义 </div> <p>这边我们关注一下type这列，这边列出主要的类型，完整的可以参考<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#explain-join-types">官方文档</a>：</p> <ul> <li>ALL（全表扫描）：对所有行扫描，效率最低下</li> <li>index（索引扫描），走索引并且不回表</li> <li>range（索引范围扫描），走索引扫描一部分数据（范围数据）</li> <li>ref（索引引用），走非唯一索引（或唯一索引的前缀部分），通常需要回表</li> </ul> <p>这里我们可以看到第一个语句type走了ref，也就是索引引用，这边我们就先不管了（理论上这里可以用联合索引增加索引级别，不过我们可以先不考虑做这个优化）</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/ref_index.2024-11-19_20-02-52-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/ref_index.2024-11-19_20-02-52-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/ref_index.2024-11-19_20-02-52-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/ref_index.2024-11-19_20-02-52.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> 索引情况 </div> <p>第二句就很奇怪，直接走ALL全表了，我们看一下索引，发现status_cd，tenant_id和org_user_id都没有任何索引</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/all_index.2024-11-22_16-04-24-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/all_index.2024-11-22_16-04-24-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/all_index.2024-11-22_16-04-24-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/all_index.2024-11-22_16-04-24.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> 索引情况 </div> <p>这边我们直接做一个联合索引</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">ALTER</span> <span class="k">TABLE</span> <span class="n">db_b</span><span class="p">.</span><span class="n">xxx_user</span>
<span class="k">ADD</span> <span class="k">INDEX</span> <span class="n">idx_status_tenant_orguser</span> <span class="p">(</span><span class="n">tenant_id</span><span class="p">,</span> <span class="n">status_cd</span><span class="p">,</span> <span class="n">org_user_id</span><span class="p">);</span>
</code></pre></div></div> <p>跑测一下看看，出乎意料的，竟然没有多少提升</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stage</span> <span class="mi">1</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">261</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">2</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">135</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">3</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">3</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">4</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">604</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">5</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">1599</span><span class="n">ms</span>
</code></pre></div></div> <p>我们也明确的看到了语句是走索引的</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/add_index.2024-11-19_20-23-08-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/add_index.2024-11-19_20-23-08-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/add_index.2024-11-19_20-23-08-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/add_index.2024-11-19_20-23-08.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> 增加索引 </div> <p>经过分析，是因为该表本身的量级不大，所以走ALL和索引的情况下，查询时间差不多。另外进一部分分析了两条SQL的执行时间，基本都是在ms级别的（分别0.12629075和0.0343075），大体是几十ms到100ms+这样的水平，实际上这边的时间分别消耗在：</p> <ol> <li>MySQL查询引擎本身，单条单次100ms来计算，按照总300ms</li> <li>网络耗时，来回的Roundtrip大概需要200ms（具体因链路情况而定），这边2次按照400ms算</li> <li>其他的都是消耗在系统层和应用层做数据拆解包、复制和解析这部分的消耗</li> </ol> <p>这边我们根据实际观测可以得出的结论是大部分时间都消耗在2、3阶段了，因此我们要继续做一个优化动作：合并数据库查询操作</p> <h3 id="合并数据库查询操作">合并数据库查询操作</h3> <p>这边我们可以看到实际上前一次查询的结果实际上是为了给后一次使用，且没有任何其他用途了，因此我们应该减少这次的网络传输和相应的应用层处理的时间，直接交给数据库引擎处理，这个在大数据集的情况下尤其有效，并且也是DB的一个能力之一。</p> <p>这边我们增加一个嵌套查询，大体为：</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span>
    <span class="k">distinct</span> <span class="n">u</span><span class="p">.</span><span class="n">account_id</span>
<span class="k">FROM</span>
    <span class="n">db_b</span><span class="p">.</span><span class="n">xxx_user</span> <span class="n">u</span>
<span class="k">INNER</span> <span class="k">JOIN</span> <span class="n">db_a</span><span class="p">.</span><span class="n">tf_org_person_rel</span> <span class="n">r</span>
<span class="k">ON</span>
    <span class="n">u</span><span class="p">.</span><span class="n">org_user_id</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">org_person_id</span>
<span class="k">WHERE</span>
    <span class="n">r</span><span class="p">.</span><span class="n">status_cd</span> <span class="o">=</span> <span class="s1">'1'</span>
    <span class="k">AND</span> <span class="n">r</span><span class="p">.</span><span class="n">org_id</span> <span class="k">IN</span> <span class="p">(</span><span class="mi">429763</span><span class="p">,</span> <span class="mi">429764</span><span class="p">,</span> <span class="mi">2361116</span><span class="p">,</span> <span class="p">...,</span> <span class="mi">2558342</span><span class="p">)</span>
    <span class="k">AND</span> <span class="n">u</span><span class="p">.</span><span class="n">status_cd</span> <span class="o">=</span> <span class="s1">'1'</span>
    <span class="k">AND</span> <span class="n">u</span><span class="p">.</span><span class="n">tenant_id</span> <span class="o">=</span> <span class="s1">'abc123'</span>
</code></pre></div></div> <p>然后我们增加3个子阶段的时间度量（其中1和2为之前剩余的2次查询，3为1和2合并的查询），跑测一下</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stage</span> <span class="mi">1</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">255</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">2</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">137</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">3</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">1</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">4</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">483</span><span class="n">ms</span>
<span class="n">Sub</span><span class="o">-</span><span class="n">Stage</span> <span class="mi">5</span><span class="p">.</span><span class="mi">1</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">740</span><span class="n">ms</span>
<span class="n">Sub</span><span class="o">-</span><span class="n">Stage</span> <span class="mi">5</span><span class="p">.</span><span class="mi">2</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">673</span><span class="n">ms</span>
<span class="n">Sub</span><span class="o">-</span><span class="n">Stage</span> <span class="mi">5</span><span class="p">.</span><span class="mi">3</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">433</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">5</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">1847</span><span class="n">ms</span>
</code></pre></div></div> <p>可以看到，1.3s可以直接所见到400ms，因为少了数据量的来回传输，传输的数据也相应的减少了，甚至单次的时间消耗都比分开的两次都低。</p> <p>整理一下代码：</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/final_code.2024-11-22_16-25-17-480.webp 480w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/final_code.2024-11-22_16-25-17-800.webp 800w,/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/final_code.2024-11-22_16-25-17-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-22-optimizing-slow-queries-from-15s-to-1s/final_code.2024-11-22_16-25-17.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> 最终优化代码 </div> <p>本身很复杂的逻辑此时已经完全简化了，实现了数据库操作复杂语句和应用层逻辑的剥离了，这也是分层的一个比较实用的逻辑和应用</p> <p>跑测一下</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stage</span> <span class="mi">1</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">213</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">2</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">118</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">3</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">3</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">4</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">486</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">5</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">496</span><span class="n">ms</span>
</code></pre></div></div> <p>可以看到，已经在ms级别了，这边看着是已经达到预期的目标了。另外还有一些优化手段，比如数据集真的大到一定量级，IN太多的情况下，可以考虑分页拉取，不过正如前面说的，除了数据库引擎层消耗以外，还有网络和应用层也会消耗，所以是需要取舍的。</p> <p>这里我们砍掉了最大头之后，可以回头对前面的阶段也优化一下，主要是针对拉全列改成拉需要的列，跑测一下看看</p> <div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Stage</span> <span class="mi">1</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">218</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">2</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">113</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">3</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">0</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">4</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">226</span><span class="n">ms</span>
<span class="n">Stage</span> <span class="mi">5</span><span class="p">:</span> <span class="o">===&gt;</span> <span class="mi">511</span><span class="n">ms</span>
</code></pre></div></div> <p>到这里的这波优化已经取得不错的成果了，这边其实还有办法进一步继续优化的，但是这个接口牵涉太多的历史业务逻辑，因此这边暂时没有继续深挖，这个其实也是很多还债过程中最难受的点，你需要保持兼容，如果前辈们没良心的堆，那大概这个草台很容易在优化重构过程中会崩塌，祝好</p> <h2 id="结论">结论</h2> <p>因为脱敏的需求，有些截图就不放了，虽然我觉得那些有助于理解整个优化过程中的思路和一步一步的优化带来的代码变迁。说到这里有时候我们在团队协作中会有结对Code Review或者定期抽样代码评审的方式，其实也是保证一个人的思路能传递给其他人，另外也能让好的思想在团队内部传播，能让新同学更快速跟上，并且长期保持团队代码质量、工程能力和协作能力。</p> <p>另外咱们还是应该坚持对事不对人，因为每个人都有一段成长期，并且很多人在面临高压或者高速增长的业务的情况下，有很大的可能出现技术债（<del>不然某节和某团的区别从何而来</del>），并且不管是谁写的东西都是有”保质期“的。</p>]]></content><author><name></name></author><category term="DB"/><category term="SQL-OPTIMIZATION"/><summary type="html"><![CDATA[SQL慢查询是老生常谈的问题了，似乎好像不会做点优化都不行。慢查询优化其实有很多手段，并且也根据应用场景和需求而异，我觉得比较重要的还是了解底层原理，这样上层应用层怎么变化都能比较快的找到优化的点。借着这个机会小谈一下SQL优化中的一些过程和想法。]]></summary></entry><entry><title type="html">Git多项目配置管理</title><link href="https://ifuryst.github.io/blog/2024/unified-git-management-for-multiple-git-repositories/" rel="alternate" type="text/html" title="Git多项目配置管理"/><published>2024-11-11T15:08:27+00:00</published><updated>2024-11-11T15:08:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/unified-git-management-for-multiple-git-repositories</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/unified-git-management-for-multiple-git-repositories/"><![CDATA[<p>平时会处理很多项目，这期间就会遇到Git相关的配置管理问题，以前都是手动管理，会遇到遗漏的情况，现在处理的项目太多了，开源社区也会参与一些项目的贡献，再手动管理很麻烦，看了一下Git是支持根据路劲来走配置的</p> <h2 id="git配置来源">Git配置来源</h2> <p>总体而言，Git读取配置主要有这么几个来源（优先级从低到高）：</p> <ol> <li>系统级（system）配置：<code class="language-plaintext highlighter-rouge">/etc/gitconfig</code></li> <li>用户级（global）配置：<code class="language-plaintext highlighter-rouge">~/.gitconfig</code></li> <li>仓库级（local）配置：项目下的<code class="language-plaintext highlighter-rouge">.git/config</code></li> </ol> <h2 id="配置命令">配置命令</h2> <p>通常情况下我们会比较多使用2和3，也就是用户级别的全局配置和单仓库级别的配置，也就是对应了以下的命令</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 全局配置</span>
git config <span class="nt">--global</span> <span class="nt">--list</span>
<span class="c"># 配置用户名</span>
git config <span class="nt">--global</span> user.name <span class="s1">'fake-name'</span>
<span class="c"># 配置邮箱</span>
git config <span class="nt">--global</span> user.email <span class="s1">'fake@email.com'</span>
<span class="c"># 配置GPG密钥ID</span>
git config <span class="nt">--global</span> user.signingkey ABC123PGPKEYID

<span class="c"># 仓库级配置</span>
git config <span class="nt">--list</span>
<span class="c"># 配置用户名</span>
git config user.name <span class="s1">'fake-name'</span>
<span class="c"># 配置邮箱</span>
git config user.email <span class="s1">'fake@email.com'</span>
<span class="c"># 配置GPG密钥ID</span>
git config user.signingkey ABC123PGPKEYID
</code></pre></div></div> <h2 id="统一配置">统一配置</h2> <p>上面的命令我们可以临时应对某些仓库临时或者单独设置，但是对于全局来说，我们不希望每次我们拉取或者起新的仓库的时候要重复配置，这会很烦人，并且重点是很多时候会忘记，因此一劳永逸的方法是根据分级配置，在全局做好配置，我个人的习惯是会根据目录来划分不同的组织项目，互不干扰</p> <p>比如此时我们有两组不同的目录里会包含各种项目：</p> <ol> <li><code class="language-plaintext highlighter-rouge">/path/to/github/</code> 包含了在开源社区的一些项目</li> <li><code class="language-plaintext highlighter-rouge">/path/to/fake-org/</code> 包含了在某个组织的项目</li> </ol> <p>此时在<code class="language-plaintext highlighter-rouge">~/.gitconfig</code>里可以这样配置</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>includeIf <span class="s2">"gitdir:/path/to/github/"</span><span class="o">]</span>
    path <span class="o">=</span> /path/to/.gitconfig.github

<span class="o">[</span>includeIf <span class="s2">"gitdir:/path/to/fake-org/"</span><span class="o">]</span>
    path <span class="o">=</span> /path/to/.gitconfig.fake-org
</code></pre></div></div> <p>这样我们就可以针对这两个目录下的项目分别走两份不同的git配置</p> <p>比如<code class="language-plaintext highlighter-rouge">.gitconfig.github</code>的配置</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>user]
    name <span class="o">=</span> <span class="s2">"leo"</span>
    email <span class="o">=</span> <span class="s2">"my@email.com"</span>
    signingkey <span class="o">=</span> <span class="s2">"ABC123"</span>
</code></pre></div></div> <p>而<code class="language-plaintext highlighter-rouge">.gitconfig.fake-org</code>的配置</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span>user]
    name <span class="o">=</span> <span class="s2">"fake-name"</span>
    email <span class="o">=</span> <span class="s2">"fake@email.com"</span>
    signingkey <span class="o">=</span> <span class="s2">"ABC456"</span>
</code></pre></div></div> <p>这样就可以一劳永逸的解决多项目不同Git配置问题</p> <h2 id="参考">参考</h2> <ul> <li><a href="https://git-scm.com/docs/git-config#Documentation/git-config.txt---global">https://git-scm.com/docs/git-config#Documentation/git-config.txt—global</a></li> </ul>]]></content><author><name></name></author><category term="DevOps"/><category term="Git"/><summary type="html"><![CDATA[平时会处理很多项目，这期间就会遇到Git相关的配置管理问题，以前都是手动管理，会遇到遗漏的情况，现在处理的项目太多了，开源社区也会参与一些项目的贡献，再手动管理很麻烦，看了一下Git是支持根据路劲来走配置的]]></summary></entry><entry><title type="html">GOMAXPROCS：Go的CPU核心数限制与容器化环境中的性能优化</title><link href="https://ifuryst.github.io/blog/2024/gomaxprocs-optimizing-go-performance-in-containers/" rel="alternate" type="text/html" title="GOMAXPROCS：Go的CPU核心数限制与容器化环境中的性能优化"/><published>2024-11-06T13:08:27+00:00</published><updated>2024-11-06T13:08:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/gomaxprocs-optimizing-go-performance-in-containers</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/gomaxprocs-optimizing-go-performance-in-containers/"><![CDATA[<p>最近遇到一个有趣的问题，关于在Cgroups限制CPU资源的情况之下，设置可用核心数的时候会导致一些性能差异，因此就这个问题探究了一下</p> <h2 id="gomaxprocs是什么">GOMAXPROCS是什么</h2> <p>GOMAXPROCS是runtime里的一个方法，看下官方的介绍</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// GOMAXPROCS sets the maximum number of CPUs that can be executing</span>
<span class="c">// simultaneously and returns the previous setting. It defaults to</span>
<span class="c">// the value of [runtime.NumCPU]. If n &lt; 1, it does not change the current setting.</span>
<span class="c">// This call will go away when the scheduler improves.</span>
<span class="k">func</span> <span class="n">GOMAXPROCS</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{}</span>
</code></pre></div></div> <p>简单的说，就是用于设置Go程序能用的CPU核心数，默认的话情况是使用所有核心（也就是runtime.NumCPU获取到的值）</p> <h2 id="gomaxprocs有什么用">GOMAXPROCS有什么用</h2> <p>在实际使用中，runtime.GOMAXPROCS多用来控制整个程序的并发量（或者说资源消耗），当设置大了，程序自然就能跑更多的协程，反之会限制同一时间的协程数量。</p> <p>通过这个我们可以在一些场景下控制资源消耗，比如有一些资源比较敏感的设备，或者小实例的场景，尤其针对以Kubernetes为主的容器化场景，通常我们会控单实例的资源，然后配合多实例实现算力切割或者容灾等目的。</p> <h2 id="具体问题">具体问题</h2> <p>通常情况下，可能不会遇到太大问题（或者不会注意到这个问题），但是在一些场景诸如高并发，关注时延（P50，P99等）、吞吐的场景，就很有可能会被影响到。</p> <p>具体的问题是，当通过Cgroups限制CPU的话，可能就会有这个问题，尤其是现在很多服务是通过Kubernetes、Docker拉起的，在容器环境里，外部可能会限制CPU、内存的最大值，这种情况在资源跑满的情况下有可能会导致实际效率比做了合适的限制来得更低的情况</p> <p>一步一步来看，可能会更加容易理解，我们拉一个容器</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">docker</span> <span class="n">run</span> <span class="o">-</span><span class="n">it</span> <span class="o">--</span><span class="n">rm</span> <span class="o">--</span><span class="n">cpus</span><span class="o">=</span><span class="s">"2"</span> <span class="o">-</span><span class="n">m</span> <span class="m">512</span><span class="n">m</span> <span class="n">golang</span><span class="o">:</span><span class="m">1.23</span><span class="o">-</span><span class="n">bullseye</span> <span class="n">bash</span>
</code></pre></div></div> <p>可以看到，这边我们限制了2核，512M的使用率限制，进到容器看看</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cpu_in_container.2024-11-06_16-34-04-480.webp 480w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cpu_in_container.2024-11-06_16-34-04-800.webp 800w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cpu_in_container.2024-11-06_16-34-04-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cpu_in_container.2024-11-06_16-34-04.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> CPU and Memory in Container </div> <p>可以看到，CPU和内存还是读取到了宿主机的实际大小，同时我们看看Cgroups</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cgroups_in_container.2024-11-06_16-40-12-480.webp 480w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cgroups_in_container.2024-11-06_16-40-12-800.webp 800w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cgroups_in_container.2024-11-06_16-40-12-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/cgroups_in_container.2024-11-06_16-40-12.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Cgroups in Container </div> <p>可以看到Cgroups确实是有设置的，这边200000/100000=2核</p> <p>我们跑个Go程序看看</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_demo.2024-11-06_16-37-08-480.webp 480w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_demo.2024-11-06_16-37-08-800.webp 800w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_demo.2024-11-06_16-37-08-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_demo.2024-11-06_16-37-08.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> GOMAXPROCS Demo </div> <p>可以看到，这边实际上获取到的也是12核，这种情况下，如果用默认的runtime.GOMAXPROCS(0)就会将最大的核心数设置成12，但是因为我们通过Cgroups限制的是2个核心，所以在2核跑满的情况之下就会出现前面提到的问题，表现为：</p> <p><strong>如果我们设置最大可用为12的情况下获得的性能是不如我们设置为2</strong></p> <h2 id="解决方案">解决方案</h2> <p>先说结论，方便下面的全流程展示。</p> <p>最直接的解决方案就是和对应的外部限制统一，可以直接通过配置传递来做，不够会比较刻板，某些情况不适应或者不灵活。</p> <p>如果是Cgroups这种情况需要动态读取的话，就需要去读取Cgroups的配置，Cgroups v1和v2有有些出入，所幸的是有对应的方案，Uber的<a href="https://github.com/uber-go/automaxprocs">automaxprocs</a>，里面针对Cgroups v1和v2做了适配读取，只支持Linux。（关于Cgroups后续有机会再展开聊聊，这边不展开了）</p> <p>值得一提的是Uber开源这个简单的工具也是因为他们在生产环境上遇到了P50、P99被这个问题影响</p> <h2 id="全流程">全流程</h2> <p>接下里我们一起通过代码来观测整个现象。</p> <p>我弄了一个Demo来演示这个结果，具体代码参见：<a href="https://github.com/iFurySt/GoMaxProcsBench">GoMaxProcsBench</a></p> <p>我们看下cmd/bench/main.go，完整代码如下</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"context"</span>
	<span class="s">"flag"</span>
	<span class="s">"fmt"</span>
	<span class="s">"go.uber.org/automaxprocs/maxprocs"</span>
	<span class="s">"log"</span>
	<span class="s">"os"</span>
	<span class="s">"os/signal"</span>
	<span class="s">"runtime"</span>
	<span class="s">"sync/atomic"</span>
	<span class="s">"syscall"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">var</span> <span class="p">(</span>
	<span class="n">mode</span>   <span class="kt">int</span>
	<span class="n">ts</span>     <span class="n">time</span><span class="o">.</span><span class="n">Duration</span>
	<span class="n">silent</span> <span class="kt">bool</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">IntVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mode</span><span class="p">,</span> <span class="s">"mode"</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"0: auto, 1: runtime"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">DurationVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="s">"ts"</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"time to run"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">BoolVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">silent</span><span class="p">,</span> <span class="s">"silent"</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="s">"silent mode"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">Parse</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">Printf</span><span class="p">(</span><span class="s">"mode: %d, ts: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
		<span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="n">runtime</span><span class="o">.</span><span class="n">NumCPU</span><span class="p">())</span>
		<span class="n">Printf</span><span class="p">(</span><span class="s">"GOMAXPROCS: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">maxprocs</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">maxprocs</span><span class="o">.</span><span class="n">Logger</span><span class="p">(</span><span class="n">Printf</span><span class="p">))</span>
	<span class="p">}</span>

	<span class="k">var</span> <span class="p">(</span>
		<span class="n">st</span>     <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>
		<span class="n">count</span>  <span class="n">atomic</span><span class="o">.</span><span class="n">Int64</span>
		<span class="n">sigs</span>   <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="n">ctx</span>    <span class="n">context</span><span class="o">.</span><span class="n">Context</span>
		<span class="n">cancel</span> <span class="n">context</span><span class="o">.</span><span class="n">CancelFunc</span>
	<span class="p">)</span>

	<span class="k">if</span> <span class="n">ts</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="p">,</span> <span class="n">cancel</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">WithTimeout</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">(),</span> <span class="n">ts</span><span class="p">)</span>
		<span class="k">defer</span> <span class="n">cancel</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">()</span>
	<span class="p">}</span>

	<span class="n">signal</span><span class="o">.</span><span class="n">Notify</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGKILL</span><span class="p">)</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">Printf</span><span class="p">(</span><span class="s">"count: %d, time: %v, qps: %.0f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">Load</span><span class="p">(),</span> <span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">st</span><span class="p">),</span>
			<span class="kt">float64</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">Load</span><span class="p">())</span><span class="o">/</span><span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">Seconds</span><span class="p">())</span>
		<span class="k">if</span> <span class="n">silent</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%.0f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kt">float64</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">Load</span><span class="p">())</span><span class="o">/</span><span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">Seconds</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">ctx</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="o">:</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">sigs</span><span class="o">:</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="n">_</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
				<span class="n">count</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
			<span class="p">}()</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Printf</span><span class="p">(</span><span class="n">format</span> <span class="kt">string</span><span class="p">,</span> <span class="n">v</span> <span class="o">...</span><span class="k">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">silent</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="n">format</span><span class="p">,</span> <span class="n">v</span><span class="o">...</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>整体逻辑很简单，我们从上到下看下</p> <p>我们用一个fibonacci来模拟耗时的计算任务</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="m">1</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">n</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fib</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="m">2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>我们定义几个参数</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="p">(</span>
	<span class="n">mode</span>   <span class="kt">int</span>
	<span class="n">ts</span>     <span class="n">time</span><span class="o">.</span><span class="n">Duration</span>
	<span class="n">silent</span> <span class="kt">bool</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">IntVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mode</span><span class="p">,</span> <span class="s">"mode"</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"0: auto, 1: runtime"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">DurationVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="s">"ts"</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"time to run"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">BoolVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">silent</span><span class="p">,</span> <span class="s">"silent"</span><span class="p">,</span> <span class="no">false</span><span class="p">,</span> <span class="s">"silent mode"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">Parse</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>分别是mode来指定走runtime.GOMAXPROCS还是automaxprocs/maxprocs</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">Printf</span><span class="p">(</span><span class="s">"mode: %d, ts: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">ts</span><span class="p">)</span>

	<span class="k">if</span> <span class="n">mode</span> <span class="o">==</span> <span class="m">1</span> <span class="p">{</span>
		<span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="n">runtime</span><span class="o">.</span><span class="n">NumCPU</span><span class="p">())</span>
		<span class="n">Printf</span><span class="p">(</span><span class="s">"GOMAXPROCS: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">runtime</span><span class="o">.</span><span class="n">GOMAXPROCS</span><span class="p">(</span><span class="m">0</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">maxprocs</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="n">maxprocs</span><span class="o">.</span><span class="n">Logger</span><span class="p">(</span><span class="n">Printf</span><span class="p">))</span>
	<span class="p">}</span>
</code></pre></div></div> <p>如果有指定ts就是运行时长，我们就通过context来控制程序到达时间退出</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="k">var</span> <span class="p">(</span>
		<span class="n">st</span>     <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span>
		<span class="n">count</span>  <span class="n">atomic</span><span class="o">.</span><span class="n">Int64</span>
		<span class="n">sigs</span>   <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="k">chan</span> <span class="n">os</span><span class="o">.</span><span class="n">Signal</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span>
		<span class="n">ctx</span>    <span class="n">context</span><span class="o">.</span><span class="n">Context</span>
		<span class="n">cancel</span> <span class="n">context</span><span class="o">.</span><span class="n">CancelFunc</span>
	<span class="p">)</span>

	<span class="k">if</span> <span class="n">ts</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">ctx</span><span class="p">,</span> <span class="n">cancel</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">WithTimeout</span><span class="p">(</span><span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">(),</span> <span class="n">ts</span><span class="p">)</span>
		<span class="k">defer</span> <span class="n">cancel</span><span class="p">()</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ctx</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">Background</span><span class="p">()</span>
	<span class="p">}</span>
</code></pre></div></div> <p>监听一下信号量，在没有指定时间的时候可以Ctrl+C来停止跑测的程序</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>	<span class="n">signal</span><span class="o">.</span><span class="n">Notify</span><span class="p">(</span><span class="n">sigs</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGQUIT</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGTERM</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGINT</span><span class="p">,</span> <span class="n">syscall</span><span class="o">.</span><span class="n">SIGKILL</span><span class="p">)</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">Printf</span><span class="p">(</span><span class="s">"count: %d, time: %v, qps: %.0f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">count</span><span class="o">.</span><span class="n">Load</span><span class="p">(),</span> <span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">st</span><span class="p">),</span>
			<span class="kt">float64</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">Load</span><span class="p">())</span><span class="o">/</span><span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">Seconds</span><span class="p">())</span>
		<span class="k">if</span> <span class="n">silent</span> <span class="p">{</span>
			<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"%.0f</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="kt">float64</span><span class="p">(</span><span class="n">count</span><span class="o">.</span><span class="n">Load</span><span class="p">())</span><span class="o">/</span><span class="n">time</span><span class="o">.</span><span class="n">Since</span><span class="p">(</span><span class="n">st</span><span class="p">)</span><span class="o">.</span><span class="n">Seconds</span><span class="p">())</span>
		<span class="p">}</span>
	<span class="p">}()</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="k">select</span> <span class="p">{</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">ctx</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span><span class="o">:</span>
			<span class="k">return</span>
		<span class="k">case</span> <span class="o">&lt;-</span><span class="n">sigs</span><span class="o">:</span>
			<span class="k">return</span>
		<span class="k">default</span><span class="o">:</span>
			<span class="k">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
				<span class="n">_</span> <span class="o">=</span> <span class="n">fib</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>
				<span class="n">count</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
			<span class="p">}()</span>
		<span class="p">}</span>
	<span class="p">}</span>
</code></pre></div></div> <p>通过for分别在context、信号量和程序之间循环，执行都是直接开个新的协程跑</p> <p>我们跑一下看看。这边可以直接通过repo里的docker-compose.yml去拉起容器测试，已经配置好了</p> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker compose up <span class="nt">-d</span>
docker compose <span class="nb">exec </span>golang bash
</code></pre></div></div> <p>我们分别跑测一下两种模式，分别跑5s</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/bench.2024-11-06_17-33-16-480.webp 480w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/bench.2024-11-06_17-33-16-800.webp 800w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/bench.2024-11-06_17-33-16-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/bench.2024-11-06_17-33-16.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Bench for GOMAXPROCS and AUTOMAXPROCS </div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@da9d799578df:/go/src/GoMaxProcsBench# go run cmd/bench/main.go <span class="nt">--ts</span> 5s <span class="nt">--mode</span> 0
2024/11/06 09:32:45 mode: 0, ts: 5s
2024/11/06 09:32:45 maxprocs: Updating <span class="nv">GOMAXPROCS</span><span class="o">=</span>2: determined from CPU quota
2024/11/06 09:32:50 count: 15323801, <span class="nb">time</span>: 5.000015461s, qps: 3064751
root@da9d799578df:/go/src/GoMaxProcsBench# go run cmd/bench/main.go <span class="nt">--ts</span> 5s <span class="nt">--mode</span> 1
2024/11/06 09:32:51 mode: 1, ts: 5s
2024/11/06 09:32:51 GOMAXPROCS: 12
2024/11/06 09:32:56 count: 8984694, <span class="nb">time</span>: 5.001722252s, qps: 1796320
</code></pre></div></div> <p>可以看到和最早分析的一样，一个用了2核一个用了12核跑，程序会打印fib运行的次数和总耗时，然后打印QPS，这边单次无法代表整体情况，我加了一个工具，我们可以通过cmd/stats/main.go来跑多次算结果，代码如下：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"flag"</span>
	<span class="s">"fmt"</span>
	<span class="s">"log"</span>
	<span class="s">"os/exec"</span>
	<span class="s">"strconv"</span>
	<span class="s">"strings"</span>
	<span class="s">"time"</span>
<span class="p">)</span>

<span class="k">var</span> <span class="p">(</span>
	<span class="n">mode</span>  <span class="kt">int</span>
	<span class="n">ts</span>    <span class="n">time</span><span class="o">.</span><span class="n">Duration</span>
	<span class="n">times</span> <span class="kt">int</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">IntVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mode</span><span class="p">,</span> <span class="s">"mode"</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"0: auto, 1: runtime"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">DurationVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="s">"ts"</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="s">"time to run"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">IntVar</span><span class="p">(</span><span class="o">&amp;</span><span class="n">times</span><span class="p">,</span> <span class="s">"times"</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="s">"times to run"</span><span class="p">)</span>
	<span class="n">flag</span><span class="o">.</span><span class="n">Parse</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">var</span> <span class="n">total</span> <span class="kt">int64</span> <span class="o">=</span> <span class="m">0</span>
	<span class="n">cnt</span> <span class="o">:=</span> <span class="m">0</span>
	<span class="k">for</span> <span class="k">range</span> <span class="n">times</span> <span class="p">{</span>
		<span class="n">cmd</span> <span class="o">:=</span> <span class="n">exec</span><span class="o">.</span><span class="n">Command</span><span class="p">(</span><span class="s">"go"</span><span class="p">,</span> <span class="s">"run"</span><span class="p">,</span> <span class="s">"cmd/bench/main.go"</span><span class="p">,</span>
			<span class="s">"--silent"</span><span class="p">,</span> <span class="s">"-mode"</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprint</span><span class="p">(</span><span class="n">mode</span><span class="p">),</span> <span class="s">"-ts"</span><span class="p">,</span> <span class="n">fmt</span><span class="o">.</span><span class="n">Sprint</span><span class="p">(</span><span class="n">ts</span><span class="o">.</span><span class="n">String</span><span class="p">()))</span>

		<span class="n">output</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">CombinedOutput</span><span class="p">()</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Failed to execute command: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="n">qps</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">strconv</span><span class="o">.</span><span class="n">ParseInt</span><span class="p">(</span><span class="n">strings</span><span class="o">.</span><span class="n">TrimSpace</span><span class="p">(</span><span class="kt">string</span><span class="p">(</span><span class="n">output</span><span class="p">)),</span> <span class="m">10</span><span class="p">,</span> <span class="m">64</span><span class="p">)</span>
		<span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="no">nil</span> <span class="p">{</span>
			<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Failed to parse output: %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
			<span class="k">continue</span>
		<span class="p">}</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">qps</span>
		<span class="n">cnt</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="n">cnt</span> <span class="o">&gt;</span> <span class="m">0</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Average QPS: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total</span><span class="o">/</span><span class="kt">int64</span><span class="p">(</span><span class="n">cnt</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">log</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"No valid result</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>我们分别跑个10次看看</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/stats.2024-11-06_17-40-44-480.webp 480w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/stats.2024-11-06_17-40-44-800.webp 800w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/stats.2024-11-06_17-40-44-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/stats.2024-11-06_17-40-44.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> Stats for GOMAXPROCS and AUTOMAXPROCS </div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>root@da9d799578df:/go/src/GoMaxProcsBench# go run cmd/stats/main.go <span class="nt">--ts</span> 5s <span class="nt">--mode</span> 0 <span class="nt">--times</span> 10
2024/11/06 09:36:29 Average QPS: 3010903
root@da9d799578df:/go/src/GoMaxProcsBench# go run cmd/stats/main.go <span class="nt">--ts</span> 5s <span class="nt">--mode</span> 1 <span class="nt">--times</span> 10
2024/11/06 09:37:33 Average QPS: 2408036
root@da9d799578df:/go/src/GoMaxProcsBench# go run cmd/stats/main.go <span class="nt">--ts</span> 5s <span class="nt">--mode</span> 0 <span class="nt">--times</span> 10
2024/11/06 09:38:41 Average QPS: 2896338
root@da9d799578df:/go/src/GoMaxProcsBench# go run cmd/stats/main.go <span class="nt">--ts</span> 5s <span class="nt">--mode</span> 1 <span class="nt">--times</span> 10
2024/11/06 09:40:25 Average QPS: 2364868
</code></pre></div></div> <p>可以看到QPS的差异了，这个case下粗略估计有20%的损耗</p> <p>这个时候如果看容器的CPU使用率可以发现，限制在2核的使用率反而更少，大概在180%，而限制在12核的CPU使用率更高，大概200%-210%</p> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_cpu_usage.2024-11-06_17-36-34-480.webp 480w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_cpu_usage.2024-11-06_17-36-34-800.webp 800w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_cpu_usage.2024-11-06_17-36-34-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/gomaxprocs_cpu_usage.2024-11-06_17-36-34.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> GOMAXPROCS CPU Usage </div> <div class="row mt-3"> <div class="col-sm mt-0 mb-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/automaxprocs_cpu_usage.2024-11-06_17-37-06-480.webp 480w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/automaxprocs_cpu_usage.2024-11-06_17-37-06-800.webp 800w,/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/automaxprocs_cpu_usage.2024-11-06_17-37-06-1400.webp 1400w," sizes="95vw" type="image/webp"/> <img src="/assets/img/2024-11-06-gomaxprocs-optimizing-go-performance-in-containers/automaxprocs_cpu_usage.2024-11-06_17-37-06.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption mt-0"> AUTOMAXPROCS CPU Usage </div> <div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CONTAINER ID   NAME                       CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O         PIDS
da9d799578df   gomaxprocsbench-golang-1   183.19%   113.3MiB / 200MiB     56.65%    69kB / 3.29kB     135MB / 195MB     53
da9d799578df   gomaxprocsbench-golang-1   210.74%   80.86MiB / 200MiB     40.43%    69kB / 3.29kB     135MB / 195MB     69
</code></pre></div></div> <h2 id="结论">结论</h2> <p>以前没有留意到这个现象的情况之下，经常会觉得在容器层面通过Cgroups来做了限制做兜底，觉得非常保险，从某种角度来说也没错，就是没有发现在CPU高负载的情况之下，可能会因为错误的配置导致性能的下降。</p> <p>很有趣的一次探索，在常规的研发过程中，很多问题不会凸显的，只有在追求一些极致的情况下，不断去抠性能损耗的情况才会开始关注这些问题，但是往往是这些东西才是前进路上最大的助推器，否则十年如一日的Coding，最后就是LLM帮你洗头。</p> <h2 id="参考">参考</h2> <ul> <li><a href="https://github.com/uber-go/automaxprocs">https://github.com/uber-go/automaxprocs</a></li> <li><a href="https://github.com/iFurySt/GoMaxProcsBench">https://github.com/iFurySt/GoMaxProcsBench</a></li> </ul>]]></content><author><name></name></author><category term="Coding"/><category term="Go"/><summary type="html"><![CDATA[最近遇到一个有趣的问题，关于在Cgroups限制CPU资源的情况之下，设置可用核心数的时候会导致一些性能差异，因此就这个问题探究了一下]]></summary></entry><entry><title type="html">关于中国酒场文化的思考</title><link href="https://ifuryst.github.io/blog/2024/reflections-on-chinas-drinking-culture/" rel="alternate" type="text/html" title="关于中国酒场文化的思考"/><published>2024-10-30T15:47:27+00:00</published><updated>2024-10-30T15:47:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/reflections-on-chinas-drinking-culture</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/reflections-on-chinas-drinking-culture/"><![CDATA[<p>牛饮，是一个很常规的印象，却也蛮符合现状的。</p> <p>在中国的酒场之上，牛饮的是酒，但是品的却是人情和利益。中性客观的描述，没有褒义也没有贬义。</p> <p>就拿我所在的地区举例，在酒桌之上，正常是主人会坐在面朝大门的中间位置，这样是能在每位来宾进来的时候第一时间看到，并且一个新进来的人第一眼也通常会先看到坐在对面中间位置的主人，合乎情理，一个小细节，通常这个位置的人就是掏钱请客的人，下次你可稍微留意一下。</p> <p>通常在酒桌之上，会有通关的“仪式”或习俗，指的是在场的每一位人都会主动和别人喝一杯酒，两个关键点：</p> <ul> <li>主动</li> <li>喝酒</li> </ul> <p>通常是从你的左手边或者右手边起势，一路打下去，别人找你喝的不算。不知这种惯例的由来，但是乍想之下是有那么几分合理性在其间。通常别人找你的话，你会比较有“感觉”，你会留意到对方，所以主动找在场的每个人喝一杯酒，也算是一个认识对方的契机，同时也能给对方一种你重视他，想敬他一杯酒的感觉。</p> <p>我发现，还蛮多人厌恶中国的酒场文化，也存在一定的合理性，其中有个原因就像那句话说的一样“不信且看杯中酒，杯杯先敬有钱人”，哈哈，也是一个很有趣的现象，充分体现人性的张力。另外一些方面其实根源和前面这个点也是相同的，在酒场之上是非常能体现“阶级”的，一些人会感觉到非常push，非常不适的原因也源于此。酒场其实也是一个小社会，桌面摊开十几个人，可能扮演了社会中的各类角色。</p> <p>当然也有一些“高端局”存在，但是酒场文化本身就是社会文化、氛围的影射，你所处的社会和你所在的酒场莫名间有一些联系。所以我觉得厌恶酒场文化本身也变得很感同身受。不过凡事均有正反面，当然人在一定的范围和限度之内都有选择。或许我们坚持不懈地努力的原因是因为我们希望能有更多的选择。</p> <p>人有主观能动性，人有欲望和想法，如果你能在做决定之前思考清楚并且对自己的决定负责，那么我觉得在很多时候，不管面对的局面是好是坏，能更加从容的面对。这一切的缘由本就是人心和底气🍺</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[牛饮，是一个很常规的印象，却也蛮符合现状的。]]></summary></entry><entry><title type="html">Go语言基于benchstat做基准测试与性能跟踪</title><link href="https://ifuryst.github.io/blog/2024/benchmarking-n-performance-tracking-in-go-using-benchstat/" rel="alternate" type="text/html" title="Go语言基于benchstat做基准测试与性能跟踪"/><published>2024-10-27T12:56:27+00:00</published><updated>2024-10-27T12:56:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/benchmarking-n-performance-tracking-in-go-using-benchstat</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/benchmarking-n-performance-tracking-in-go-using-benchstat/"><![CDATA[<h1 id="benchmark">Benchmark</h1> <p>在开发过程中，我们会做一些基准测试（Benchmark），用于去评估一些函数之间的性能差异，比如常规情况我们可能会这样做：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">slice</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"sort"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">SortedIncludes</span><span class="p">(</span><span class="n">strArray</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">target</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">sort</span><span class="o">.</span><span class="n">Strings</span><span class="p">(</span><span class="n">strArray</span><span class="p">)</span>
	<span class="n">index</span> <span class="o">:=</span> <span class="n">sort</span><span class="o">.</span><span class="n">SearchStrings</span><span class="p">(</span><span class="n">strArray</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">strArray</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">strArray</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">Contains</span><span class="p">[</span><span class="n">T</span> <span class="n">comparable</span><span class="p">](</span><span class="n">list</span> <span class="p">[]</span><span class="n">T</span><span class="p">,</span> <span class="n">ele</span> <span class="n">T</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">list</span> <span class="p">{</span>
		<span class="k">if</span> <span class="n">v</span> <span class="o">==</span> <span class="n">ele</span> <span class="p">{</span>
			<span class="k">return</span> <span class="no">true</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkSortedIncludes</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">SortedIncludes</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">BenchmarkContains</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">Contains</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>我们跑测之后的结果如下：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># go test -bench=. -benchmem ./slice/slice_including_test.go</span>
goos: darwin
goarch: arm64
cpu: Apple M3 Pro
BenchmarkSortedIncludes-12      60017379                21.56 ns/op            0 B/op          0 allocs/op
BenchmarkContains-12            653826099                1.877 ns/op           0 B/op          0 allocs/op
PASS
ok      command-line-arguments  3.856s
</code></pre></div></div> <p>这种情况下我们是可以直接根据基准测试的结果很明确的知道<code class="language-plaintext highlighter-rouge">Contains</code>的效率是更好的。</p> <p>但是在实际的实践中，上面这种方式只适合我们在开发的时候对比测试最后选用的这样一个情况，之后这个基准测试对我们几乎是没有用处了，我们也很难持续跟踪某个函数的性能变化情况。基于这个问题，benchstat在某种程度上是可以帮我们解决这个问题。</p> <h1 id="benchstat">Benchstat</h1> <p><a href="https://github.com/iFurySt/go-benchstat-demo">https://github.com/iFurySt/go-benchstat-demo</a></p> <p>这一节相关的代码和命令我都整理在这个repo里了</p> <blockquote> <p>Benchstat computes statistical summaries and A/B comparisons of Go benchmarks.</p> </blockquote> <p>简而言之，benchstat就是用来做基准测试对比的，可以是一次改动的前后对比，也可以是和历史的某次对比。这样其实是可以持续跟踪性能变化的</p> <p>这里我们模拟了一个业务调用一个函数的逻辑：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"fmt"</span>
	<span class="s">"github.com/ifuryst/go-benchstat-demo/pkg/util"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">mockBiz</span><span class="p">()</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">mockBiz</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ss</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">}</span>
	<span class="n">s1</span> <span class="o">:=</span> <span class="s">"a"</span>
	<span class="n">isInclude</span> <span class="o">:=</span> <span class="n">util</span><span class="o">.</span><span class="n">Includes</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">s1</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Is %s in %v? %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">isInclude</span><span class="p">)</span>
	<span class="n">s2</span> <span class="o">:=</span> <span class="s">"d"</span>
	<span class="n">isInclude</span> <span class="o">=</span> <span class="n">util</span><span class="o">.</span><span class="n">Includes</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span>
	<span class="n">fmt</span><span class="o">.</span><span class="n">Printf</span><span class="p">(</span><span class="s">"Is %s in %v? %v</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">ss</span><span class="p">,</span> <span class="n">isInclude</span><span class="p">)</span>
<span class="p">}</span>

</code></pre></div></div> <p>相关的函数：</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">util</span>

<span class="k">import</span> <span class="s">"sort"</span>

<span class="k">func</span> <span class="n">Includes</span><span class="p">(</span><span class="n">ss</span> <span class="p">[]</span><span class="kt">string</span><span class="p">,</span> <span class="n">s</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="n">sort</span><span class="o">.</span><span class="n">Strings</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>
	<span class="n">index</span> <span class="o">:=</span> <span class="n">sort</span><span class="o">.</span><span class="n">SearchStrings</span><span class="p">(</span><span class="n">ss</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
	<span class="k">if</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ss</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">==</span> <span class="n">s</span> <span class="p">{</span>
		<span class="k">return</span> <span class="no">true</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="no">false</span>
<span class="p">}</span>
</code></pre></div></div> <p>就是一个简单的在列表里查找某个值是否存在，上面这个是v1.0.0的版本，到v2.0.0了这个方法被改进了</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">util</span>

<span class="k">import</span> <span class="s">"testing"</span>

<span class="k">func</span> <span class="n">BenchmarkInclude</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">Includes</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这种情况其实我们可能不知道性能整体是怎样变化的，因此我们分别对biz和Include增加一下benchmark</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"os"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">BenchmarkBiz</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">old</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span>
	<span class="n">devNull</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">os</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">DevNull</span><span class="p">)</span>
	<span class="k">defer</span> <span class="n">devNull</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
	<span class="n">os</span><span class="o">.</span><span class="n">Stdout</span> <span class="o">=</span> <span class="n">devNull</span>
	<span class="k">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span> <span class="n">os</span><span class="o">.</span><span class="n">Stdout</span> <span class="o">=</span> <span class="n">old</span> <span class="p">}()</span>

	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">mockBiz</span><span class="p">()</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>以及</p> <div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">package</span> <span class="n">util</span>

<span class="k">import</span> <span class="s">"testing"</span>

<span class="k">func</span> <span class="n">BenchmarkInclude</span><span class="p">(</span><span class="n">b</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">B</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">.</span><span class="n">N</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">Includes</span><span class="p">([]</span><span class="kt">string</span><span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">},</span> <span class="s">"a"</span><span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>这个时候我们是可以通过go test做基准测试的，这个时候我们可以在两个版本分别做一下</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git checkout v1.0.0
go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span><span class="nb">.</span> <span class="nt">-benchmem</span> <span class="nt">-count</span><span class="o">=</span>10 ./... <span class="o">&gt;</span> old-<span class="sb">`</span>git rev-parse HEAD<span class="sb">`</span>.txt
git checkout v2.0.0
go <span class="nb">test</span> <span class="nt">-bench</span><span class="o">=</span><span class="nb">.</span> <span class="nt">-benchmem</span> <span class="nt">-count</span><span class="o">=</span>10 ./... <span class="o">&gt;</span> new-<span class="sb">`</span>git rev-parse HEAD<span class="sb">`</span>.txt
</code></pre></div></div> <p>这个命令就是做benchmark，同时也统计内存的情况，跑10次基准测试是为了减少一些误差，将结果分别输出到两个文件，然后我们就可以用benchstat对比这两个文件</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>benchstat old-<span class="k">*</span>.txt new-<span class="k">*</span>.txt
</code></pre></div></div> <p>输出结果如下：</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>goos: darwin
goarch: arm64
pkg: github.com/ifuryst/go-benchstat-demo
cpu: Apple M3 Pro
       │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
       │                      sec/op                      │          sec/op            vs base               │
Biz-12                                        914.4n ± 2%                 881.4n ± 4%  <span class="nt">-3</span>.61% <span class="o">(</span><span class="nv">p</span><span class="o">=</span>0.007 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span>

       │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
       │                       B/op                       │             B/op              vs base            │
Biz-12                                         320.0 ± 0%                     320.0 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

       │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
       │                    allocs/op                     │          allocs/op            vs base            │
Biz-12                                         13.00 ± 0%                     13.00 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

pkg: github.com/ifuryst/go-benchstat-demo/pkg/util
           │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
           │                      sec/op                      │          sec/op           vs base                │
Include-12                                       20.095n ± 2%                1.881n ± 1%  <span class="nt">-90</span>.64% <span class="o">(</span><span class="nv">p</span><span class="o">=</span>0.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span>

           │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
           │                       B/op                       │             B/op              vs base            │
Include-12                                         0.000 ± 0%                     0.000 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

           │ old-3d43a88772ed24c341f60e41122828fe38594870.txt │ new-a7d9ff564525bee68aedcb03a1bf9ef5f53b3a79.txt │
           │                    allocs/op                     │          allocs/op            vs base            │
Include-12                                         0.000 ± 0%                     0.000 ± 0%  ~ <span class="o">(</span><span class="nv">p</span><span class="o">=</span>1.000 <span class="nv">n</span><span class="o">=</span>10<span class="o">)</span> ¹
¹ all samples are equal

</code></pre></div></div> <p>让ChatGPT🤖帮我们组织美化成表格可能更好看：</p> <p>Package: <code class="language-plaintext highlighter-rouge">github.com/ifuryst/go-benchstat-demo</code></p> <p>CPU: Apple M3 Pro (<code class="language-plaintext highlighter-rouge">goos: darwin</code>, <code class="language-plaintext highlighter-rouge">goarch: arm64</code>)</p> <table> <thead> <tr> <th>Test</th> <th>Metric</th> <th>Old (sec/op)</th> <th>New (sec/op)</th> <th>Change</th> <th>P-Value</th> <th>Samples</th> </tr> </thead> <tbody> <tr> <td>Biz-12</td> <td>sec/op</td> <td>914.4n ± 2%</td> <td>881.4n ± 4%</td> <td>-3.61%</td> <td>p=0.007</td> <td>n=10</td> </tr> <tr> <td>Biz-12</td> <td>B/op</td> <td>320.0 ± 0%</td> <td>320.0 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> <tr> <td>Biz-12</td> <td>allocs/op</td> <td>13.00 ± 0%</td> <td>13.00 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> </tbody> </table> <p>Package: <code class="language-plaintext highlighter-rouge">github.com/ifuryst/go-benchstat-demo/pkg/util</code></p> <table> <thead> <tr> <th>Test</th> <th>Metric</th> <th>Old (sec/op)</th> <th>New (sec/op)</th> <th>Change</th> <th>P-Value</th> <th>Samples</th> </tr> </thead> <tbody> <tr> <td>Include-12</td> <td>sec/op</td> <td>20.095n ± 2%</td> <td>1.881n ± 1%</td> <td>-90.64%</td> <td>p=0.000</td> <td>n=10</td> </tr> <tr> <td>Include-12</td> <td>B/op</td> <td>0.000 ± 0%</td> <td>0.000 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> <tr> <td>Include-12</td> <td>allocs/op</td> <td>0.000 ± 0%</td> <td>0.000 ± 0%</td> <td>~ (no change)</td> <td>p=1.000</td> <td>n=10</td> </tr> </tbody> </table> <p>解释一下这几个列的含义：</p> <ul> <li>Test：对应的基准测试的名称</li> <li>Metric：测量的指标： <ul> <li>sec/op：每个操作花费的秒数，用来衡量函数执行一个操作所需的时间，越低越好。</li> <li>B/op：每个操作分配的字节数，用来衡量函数执行时内存分配的大小，越少越好。</li> <li>allocs/op: 每个操作的内存分配次数，用来衡量函数执行时发生了多少次内存分配，越少越好。</li> </ul> </li> <li>Old (sec/op)：旧版本的基准测试结果平均花费时间和误差范围</li> <li>New (sec/op):：新版本的基准测试结果</li> <li>Change：新旧版本性能的变化百分比，负值表示性能提升</li> <li>P-Value：统计学中的P值，用来衡量结果的显著性，一般来说小于0.05就是效果显著，1就是差异不明显</li> <li>Samples：基准测试的样本数量，表示每个基准测试的运行次数</li> </ul> <p>我们可以很直观的从表格里看出，v2的时候Include的执行时间提升了90%，但是我们同时可以看到对于Biz来说整体其实是没怎么提升的，这里应该是打印日志把整体的性能都拉低了，导致压不出来</p> <p>有了benchstat，我们其实是可以在CI环节就可以针对PR对比前后的性能变化，也可以按照发布的版本在每次发版前跟踪版本间的性能差异</p> <h1 id="references">References</h1> <ul> <li><a href="https://pkg.go.dev/golang.org/x/perf/cmd/benchstat">https://pkg.go.dev/golang.org/x/perf/cmd/benchstat</a></li> <li><a href="https://github.com/iFurySt/go-benchstat-demo">https://github.com/iFurySt/go-benchstat-demo</a></li> </ul>]]></content><author><name></name></author><category term="Coding"/><category term="Go"/><summary type="html"><![CDATA[Benchmark]]></summary></entry><entry><title type="html">MacOS Sequoia 15.0.1 Option热键绑定失效问题</title><link href="https://ifuryst.github.io/blog/2024/resolving-option-key-hotkey-issues-in-macos-sequoia/" rel="alternate" type="text/html" title="MacOS Sequoia 15.0.1 Option热键绑定失效问题"/><published>2024-10-17T14:00:27+00:00</published><updated>2024-10-17T14:00:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/resolving-option-key-hotkey-issues-in-macos-sequoia</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/resolving-option-key-hotkey-issues-in-macos-sequoia/"><![CDATA[<h1 id="背景">背景</h1> <p>问题是15.0.1禁用<code class="language-plaintext highlighter-rouge">Option+*</code>或者<code class="language-plaintext highlighter-rouge">Option+Shift+*</code>热键绑定，相关讨论看这里</p> <p><a href="https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/">https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/</a></p> <p>官方对此的说法是：<a href="https://developer.apple.com/forums/thread/763878?answerId=804374022#804374022">这是一个有意为之的改变</a></p> <h1 id="方案-hammerspoon">方案: Hammerspoon</h1> <p>相信很多人都会用<code class="language-plaintext highlighter-rouge">Option</code>来绑定自定义的热键，因为<code class="language-plaintext highlighter-rouge">Command</code>和<code class="language-plaintext highlighter-rouge">Control</code>键已经被大量场景占用了。我也是以前经常会使用<code class="language-plaintext highlighter-rouge">Option+*</code> 来快速切换应用的焦点，比如C代表Chrome，S代表Sublime Text，现在不能用了略难受，发现了一个方式可以实现，就是用<code class="language-plaintext highlighter-rouge">Hammerspoon</code> （Reddit里<a href="https://www.reddit.com/r/macapps/comments/1fjpiiw/comment/lolslnm/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button">danrnx</a>的回复给了我灵感）</p> <p><a href="https://github.com/Hammerspoon/hammerspoon">https://github.com/Hammerspoon/hammerspoon</a></p> <h2 id="安装">安装</h2> <p>具体方式如下</p> <ol> <li>安装应用，Release里下载或者brew安装</li> <li>配置，写lua，保存到<code class="language-plaintext highlighter-rouge">~/.hammerspoon/init.lua</code></li> </ol> <p>可以参考官方的<a href="https://www.hammerspoon.org/go/">指导</a></p> <h2 id="示例">示例</h2> <h3 id="示例1-不是焦点时获取应用焦点并打印文字">示例1: 不是焦点时获取应用焦点并打印文字</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hs.hotkey.bind<span class="o">({</span><span class="s2">"alt"</span><span class="o">}</span>, <span class="s2">"C"</span>, <span class="k">function</span><span class="o">()</span>
  <span class="nb">local </span>currentApp <span class="o">=</span> hs.application.frontmostApplication<span class="o">()</span>

  <span class="k">if </span>currentApp:name<span class="o">()</span> <span class="o">==</span> <span class="s2">"Google Chrome"</span> <span class="k">then</span>
    <span class="nt">--</span> 焦点已经在 Chrome，不显示 alert
    <span class="k">return
  else
    </span>hs.alert.show<span class="o">(</span><span class="s2">"Chrome"</span><span class="o">)</span>
    hs.application.launchOrFocus<span class="o">(</span><span class="s2">"Google Chrome"</span><span class="o">)</span>
  end
end<span class="o">)</span>
</code></pre></div></div> <h3 id="示例2-不是焦点时获取应用焦点并打印图标">示例2: 不是焦点时获取应用焦点并打印图标</h3> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>hs.hotkey.bind<span class="o">({</span><span class="s2">"alt"</span><span class="o">}</span>, <span class="s2">"C"</span>, <span class="k">function</span><span class="o">()</span>
  <span class="nb">local </span>currentApp <span class="o">=</span> hs.application.frontmostApplication<span class="o">()</span>

  <span class="k">if </span>currentApp:name<span class="o">()</span> <span class="o">==</span> <span class="s2">"Google Chrome"</span> <span class="k">then</span>
    <span class="nt">--</span> 焦点已经在 Chrome，不显示 alert
    <span class="k">return
  else
    </span><span class="nb">local </span>chromeIcon <span class="o">=</span> hs.image.imageFromAppBundle<span class="o">(</span><span class="s2">"com.google.Chrome"</span><span class="o">)</span>

    <span class="nt">--</span> 创建一个 canvas 显示图标
    <span class="nb">local </span>iconCanvas <span class="o">=</span> hs.canvas.new<span class="o">{</span> x <span class="o">=</span> 0, y <span class="o">=</span> 0, h <span class="o">=</span> 100, w <span class="o">=</span> 100 <span class="o">}</span>:appendElements<span class="o">({</span>
      <span class="nb">type</span> <span class="o">=</span> <span class="s2">"image"</span>,
      image <span class="o">=</span> chromeIcon,
      imageAlignment <span class="o">=</span> <span class="s2">"center"</span>,
      imageScaling <span class="o">=</span> <span class="s2">"scaleToFit"</span>
    <span class="o">})</span>

    <span class="nt">--</span> 获取屏幕中心位置，显示 canvas
    <span class="nb">local </span>screenFrame <span class="o">=</span> hs.screen.mainScreen<span class="o">()</span>:frame<span class="o">()</span>
    iconCanvas:frame<span class="o">({</span>
      x <span class="o">=</span> screenFrame.w / 2 - 50,
      y <span class="o">=</span> screenFrame.h / 2 - 50,
      h <span class="o">=</span> 100,
      w <span class="o">=</span> 100
    <span class="o">})</span>

    <span class="nt">--</span> 显示图标，并在1秒后自动删除
    iconCanvas:show<span class="o">()</span>
    hs.timer.doAfter<span class="o">(</span>1, <span class="k">function</span><span class="o">()</span> iconCanvas:delete<span class="o">()</span> end<span class="o">)</span>

    hs.application.launchOrFocus<span class="o">(</span><span class="s2">"Google Chrome"</span><span class="o">)</span>
  end
end<span class="o">)</span>
</code></pre></div></div> <p>bundle id可以通过命令查看(下面的示例里封装了自动获取bundle id)</p> <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>osascript <span class="nt">-e</span> <span class="s1">'id of app "iTerm"'</span>
osascript <span class="nt">-e</span> <span class="s1">'id of app "Google Chrome"'</span>
</code></pre></div></div> <h3 id="示例3-打开应用">示例3: 打开应用</h3> <p>跟2类似，封装了一下，可以复用</p> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 1. Open Application --</span>
<span class="k">function</span> <span class="nf">getBundleID</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">app</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>

  <span class="k">if</span> <span class="n">app</span> <span class="k">then</span>
    <span class="k">return</span> <span class="n">app</span><span class="p">:</span><span class="n">bundleID</span><span class="p">()</span>
  <span class="k">else</span>
    <span class="c1">-- 如果应用未运行，通过应用路径获取</span>
    <span class="kd">local</span> <span class="n">appPath</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">pathForBundleID</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">appPath</span> <span class="k">then</span>
      <span class="k">return</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">infoForBundlePath</span><span class="p">(</span><span class="n">appPath</span><span class="p">).</span><span class="n">CFBundleIdentifier</span>
    <span class="k">else</span>
      <span class="n">hs</span><span class="p">.</span><span class="n">alert</span><span class="p">.</span><span class="n">show</span><span class="p">(</span><span class="s2">"Application not found: "</span> <span class="o">..</span> <span class="n">appName</span><span class="p">)</span>
      <span class="k">return</span> <span class="kc">nil</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1">-- 通用函数，用于绑定热键并处理应用程序启动或聚焦</span>
<span class="k">function</span> <span class="nf">bindAppHotkey</span><span class="p">(</span><span class="n">modifiers</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">appName</span><span class="p">)</span>
  <span class="kd">local</span> <span class="n">bundleID</span> <span class="o">=</span> <span class="n">getBundleID</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>

  <span class="k">if</span> <span class="ow">not</span> <span class="n">bundleID</span> <span class="k">then</span>
    <span class="k">return</span>
  <span class="k">end</span>

  <span class="n">hs</span><span class="p">.</span><span class="n">hotkey</span><span class="p">.</span><span class="n">bind</span><span class="p">(</span><span class="n">modifiers</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span>
    <span class="kd">local</span> <span class="n">currentApp</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">frontmostApplication</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">currentApp</span><span class="p">:</span><span class="n">bundleID</span><span class="p">()</span> <span class="o">==</span> <span class="n">bundleID</span> <span class="k">then</span>
      <span class="k">return</span>
    <span class="k">else</span>
      <span class="kd">local</span> <span class="n">appIcon</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">image</span><span class="p">.</span><span class="n">imageFromAppBundle</span><span class="p">(</span><span class="n">bundleID</span><span class="p">)</span>

      <span class="c1">-- 创建一个 canvas 显示图标</span>
      <span class="kd">local</span> <span class="n">iconCanvas</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">canvas</span><span class="p">.</span><span class="n">new</span><span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span> <span class="n">w</span> <span class="o">=</span> <span class="mi">100</span> <span class="p">}:</span><span class="n">appendElements</span><span class="p">({</span>
        <span class="nb">type</span> <span class="o">=</span> <span class="s2">"image"</span><span class="p">,</span>
        <span class="n">image</span> <span class="o">=</span> <span class="n">appIcon</span><span class="p">,</span>
        <span class="n">imageAlignment</span> <span class="o">=</span> <span class="s2">"center"</span><span class="p">,</span>
        <span class="n">imageScaling</span> <span class="o">=</span> <span class="s2">"scaleToFit"</span>
      <span class="p">})</span>

      <span class="c1">-- 获取屏幕中心位置，显示 canvas</span>
      <span class="kd">local</span> <span class="n">screenFrame</span> <span class="o">=</span> <span class="n">hs</span><span class="p">.</span><span class="n">screen</span><span class="p">.</span><span class="n">mainScreen</span><span class="p">():</span><span class="n">frame</span><span class="p">()</span>
      <span class="n">iconCanvas</span><span class="p">:</span><span class="n">frame</span><span class="p">({</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">screenFrame</span><span class="p">.</span><span class="n">w</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">screenFrame</span><span class="p">.</span><span class="n">h</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">50</span><span class="p">,</span>
        <span class="n">h</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">w</span> <span class="o">=</span> <span class="mi">100</span>
      <span class="p">})</span>

      <span class="c1">-- 显示图标，并在1秒后自动删除</span>
      <span class="n">iconCanvas</span><span class="p">:</span><span class="n">show</span><span class="p">()</span>
      <span class="n">hs</span><span class="p">.</span><span class="n">timer</span><span class="p">.</span><span class="n">doAfter</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span> <span class="n">iconCanvas</span><span class="p">:</span><span class="n">delete</span><span class="p">()</span> <span class="k">end</span><span class="p">)</span>

      <span class="c1">-- 启动或聚焦应用程序</span>
      <span class="n">hs</span><span class="p">.</span><span class="n">application</span><span class="p">.</span><span class="n">launchOrFocus</span><span class="p">(</span><span class="n">appName</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1">-- 使用通用函数为不同的应用程序设置热键</span>
<span class="n">bindAppHotkey</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"C"</span><span class="p">,</span> <span class="s2">"Google Chrome"</span><span class="p">)</span>
<span class="n">bindAppHotkey</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"S"</span><span class="p">,</span> <span class="s2">"Sublime Text"</span><span class="p">)</span>
<span class="n">bindAppHotkey</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"space"</span><span class="p">,</span> <span class="s2">"iTerm"</span><span class="p">)</span>
</code></pre></div></div> <h3 id="示例4-热键转移再触发">示例4: 热键转移，再触发</h3> <p>抛开应用开启，某些情况下需要其他功能，比如截图，这个时候本身截图是在应用里设置的热键，这种情况就需要通过一下小技巧转移热键，等于代理了</p> <div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">-- 2. retrigger --</span>
<span class="n">hs</span><span class="p">.</span><span class="n">hotkey</span><span class="p">.</span><span class="n">bind</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">},</span> <span class="s2">"A"</span><span class="p">,</span> <span class="k">function</span><span class="p">()</span>
  <span class="n">hs</span><span class="p">.</span><span class="n">eventtap</span><span class="p">.</span><span class="n">keyStroke</span><span class="p">({</span><span class="s2">"alt"</span><span class="p">,</span> <span class="s2">"cmd"</span><span class="p">},</span> <span class="s2">"A"</span><span class="p">)</span>
<span class="k">end</span><span class="p">)</span>
</code></pre></div></div> <p>这里就是在按<code class="language-plaintext highlighter-rouge">Option+A</code>的时候再触发按<code class="language-plaintext highlighter-rouge">Option+Cmd+A</code></p> <h1 id="参考">参考</h1> <ul> <li><a href="https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/">https://www.reddit.com/r/macapps/comments/1fjpiiw/psa_macos_15_breaks_optionkey_hotkeys/</a></li> <li><a href="https://developer.apple.com/forums/thread/763878?answerId=804374022#804374022">https://developer.apple.com/forums/thread/763878?answerId=804374022#804374022</a></li> <li><a href="https://www.hammerspoon.org/">https://www.hammerspoon.org/</a></li> </ul>]]></content><author><name></name></author><category term="tricks"/><category term="MacOS"/><summary type="html"><![CDATA[背景]]></summary></entry><entry><title type="html">观点认同问题 / The Challenge of Opinion Shaping in the Digital Age</title><link href="https://ifuryst.github.io/blog/2024/the-challenge-of-opinion-shaping-in-the-digital-age/" rel="alternate" type="text/html" title="观点认同问题 / The Challenge of Opinion Shaping in the Digital Age"/><published>2024-10-09T15:19:27+00:00</published><updated>2024-10-09T15:19:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/the-challenge-of-opinion-shaping-in-the-digital-age</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/the-challenge-of-opinion-shaping-in-the-digital-age/"><![CDATA[<p>很久以前看到一个说法，原话记不清楚了，但是大体的意思是，现在人的观点太容易被互联网上的言论给左右了，可能你现在看到这个观点你觉得很有道理，一会你又看到了另外一个观点，同样也觉得很有道理，你的观点在不断的被左右</p> <p>一直以来我都认为这个说法很对，我很认可（这个时候我就是故事中的人了），但是今天我开始有点质疑这个说法了。</p> <p>首先是我觉得互联网就是这么个神奇的东西，这个世界那么多人，都能在这之上很迅速很便捷的进行交流，因此也衍生出了一批自媒体，广义层面的，比如我写的这些文章，我可以很简单的发布到网上，会有人看得到。在这种角度来看，你能看到你认可的观点我觉得没有丝毫可称奇的地方。</p> <p>我们能看到某篇文章、某个说法、某个观点等等，进而认可，我觉得原因有很多了，比如作者本身的表述就相对来说很自洽，很容说服人，我觉得在庞大的网民群里之上，你能看到的毕竟是少数，这些内容从某些层面就是更佳有突出重围的优势。这其中也不乏各类推荐算法，使得我们更加容易获取到自身认可的信息。</p> <p>因此我觉得从获取信息的角度来看，这没什么问题，我们认可观点也是非常自然的事情。从辩论或者论证的角度，有些情况下我们很有可能同时认可正反双方的观点，这也会让我们感觉自己像是“墙头草”，对正反观点都觉得很有道理很认可。</p> <p>另外就是自我们自己的思维不够完备不够自洽的情况之下，我们会更容易接受别人的观点，我觉得这也无可厚非。如果我们从一开始就抱着文章开头的想法，时刻提醒自己不要被这些观点随意左右，那很有可能我们会进入一种误区，毕竟我觉得谁也不敢保证在某些方面的观点从一开始就是对的？如果你不持续接收外部的观点来影响自己，那思想如何进一步完善呢？因此如果轻易采信，可能也间接说明了太容易被其他人的观点影响了，进一步固步自封了？这里有点套娃的感觉，如果你觉得这句话有道理，你就有可能是这句话里面表达的那种人。</p> <p>因此我觉得哪怕被各类观点带着跑，依然可以尝试去理解别人的观点立场，这样有助于形成自己的判断。但是这里面也有不少陷阱啦，比如现在的仇恨言论化，观点极化，非黑即白，本身就是互联网短平快带来的副作用，因此我们应该警惕这些点，进一步形成自己的小宇宙。</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[很久以前看到一个说法，原话记不清楚了，但是大体的意思是，现在人的观点太容易被互联网上的言论给左右了，可能你现在看到这个观点你觉得很有道理，一会你又看到了另外一个观点，同样也觉得很有道理，你的观点在不断的被左右]]></summary></entry><entry><title type="html">用科学的手段重新认识习以为常的事物 / Reevaluating the Familiar Through a Scientific Lens</title><link href="https://ifuryst.github.io/blog/2024/reevaluating-the-familiar-through-a-scientific-lens/" rel="alternate" type="text/html" title="用科学的手段重新认识习以为常的事物 / Reevaluating the Familiar Through a Scientific Lens"/><published>2024-09-30T15:12:27+00:00</published><updated>2024-09-30T15:12:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/reevaluating-the-familiar-through-a-scientific-lens</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/reevaluating-the-familiar-through-a-scientific-lens/"><![CDATA[<p>我们有很多的认知都来源于代代口述相传和切身感受的经验组成，尤其是对于很多日常中出现的事物，而且这些东西在教育体系中鲜少涉及（部分专业学习中可能会涉及），这会导致一些认知的固化，并且会完全没有意识去翻新陈旧或者错误的认知。</p> <p>其实对于这个想法由来以久了，在很长的一段时间内我都会时不时留意到这个问题，但是存在这么久也是有原因的，我仔细思考了一下，有这么几个原因：</p> <ol> <li>惯性太强</li> <li>惰性太强</li> <li>没有找到更易于入手理解的完整的知识</li> </ol> <p>最近在阅读一本叫做《睡眠革命》（尼克·利特尔黑尔斯）的书，以上的念头再次涌上心头。借此机会以睡眠这个事情来聊聊这个话题</p> <p>对于睡眠，我的看法经历过很多次变化，大体如下：</p> <ul> <li>小时候需要充足的睡眠，晚上也能很轻松入睡</li> <li>青少年时期会熬夜玩电脑玩手机，白天睡到自然醒</li> <li>大学时觉得自己不能睡太多，开始管理自己尽可能早点起床</li> <li>觉得自己死了可以长眠，强迫自己不多睡</li> <li>毕业后创业，作息相对不规律，但仍能保持相对规律的睡眠</li> <li>现在是拒绝午睡，晚睡早起但需要修复</li> </ul> <p>现在看看其实这里面存在很多的认知错误已经错误的决策，不过好在目前还没有造成比较严重的后果，我仍然有机会进一步科学的矫正自己对于睡眠的认知，并作出更好的决策</p> <h2 id="早睡星人和晚睡星人">早睡星人和晚睡星人</h2> <p>结合这本书来看一下，书中说到，睡眠分为2个类型：</p> <ol> <li>早睡星人：早睡早起，甚至不需要闹钟</li> <li>晚睡星人：早睡困难早起困难</li> </ol> <p>我觉得蛮多现代的年轻人会将自己归类到第二类，我觉得我是偏向第二类的，我经常很惊讶和赞叹我的某些朋友可以做到早上很早就自然醒的能力，虽然我通过自我约束和强迫能达到类似的状态，但是我做不到靠生物钟之类的内在力量做到。</p> <p>书中也提到，这个社会的制度似乎天然会对晚睡星人不友好，我们姑且相信这两类人是客观存在的，因为有一些观念会偏向性的认为，晚睡的人就是“有问题”，我觉得这个也是一个非常令人讨厌和心痛的问题。以我个人以及周边人的经历来说，父母们会叫你早睡早起，不希望你晚起，希望你起来吃早餐，一切的出发点看着都是没有问题的，但是问题在于劝导方式非常难以接受，甚至进一步造就了我们的认知：</p> <ul> <li>觉得失眠的人是有问题，但是我们应该正视一些疾病存在的可能</li> <li>觉得不早睡是玩电脑、玩手机或看电视之类的问题，这个是客观存在</li> <li>觉得晚起不好，但是怎么不好却经常挺难说出来的，以及一位的劝导早起</li> </ul> <p>不过我觉得也无可厚非，这也是教育的意义吧，因为以我这个年龄来说，上一代人普遍的通识教育程度都比较低，更遑论针对性的学习。我觉得我们应该更加科学的看待这些问题，比如书中提到的几个点都非常棒，我们一起来看看</p> <h2 id="昼夜节律">昼夜节律</h2> <p>人类从农耕文明一直到现在，经历过很多次的大革命，但是物种的进化速度是很慢的，因为我们还保留了农耕时代的作息规律，也就是夜间睡眠，白天劳作的规律，在一天24小时的过程中，人体的状态也分了好多个阶段。</p> <p>这里我们可以了解到夜间9点多的时候释放褪黑素，</p> <h2 id="15h一个周期的r90方案">1.5h一个周期的R90方案</h2> <p>其实我一直有这个迷思，同样的睡眠时间，7点起，8点起，有可能后者更加困，那就很奇怪了，明明我多睡了一小时了呀？为什么我更困了呢。以前我自己感悟出来的是：我觉得睡眠是有个周期的，你超过这个周期如果没睡满就很困，但是我不知道如何能完美的卡到这个档，也不知道周期有多长。</p> <p>本书作者给出了一个叫做R90的方案，也就是以90分钟（1.5h）为周期，人一天需要4或者5个周期。作者建议，如果你能完成一整个周期的睡眠是最好的，如果不能你可以考虑放弃掉这个周期。比如说5个周期为例子，00:00睡到7:30是5个周期，如果你在01:00的时候还没睡，你可以考虑让自己在黑暗的环境下（促进褪黑素分泌已经精神放松）放松30分钟后入睡，这样你拥有了4个完整周期，这种情况可能会好过直接入睡</p> <h2 id="睡懒觉-可控修复期">🚫睡懒觉 ✅可控修复期</h2> <p>我现在不午睡了，一半是我习惯了，另一半是我能忍住。我以前也会午睡，但是自从我每天中午开始学习英语后，我放弃了午睡。对于午睡就像前面说到的，我似乎不想让我自己进行午睡，我更希望好好利用这个时间来做一些我自认为有意义的事情。</p> <p>这本书给我一个比较惊奇的点就是这个可控修复期了，书中作者将午睡的概念表述成可控修复期，我非常非常喜欢这个称呼。我会更加有意愿的去平衡午睡和不午睡的时间，因为如果我希望自己的身体能保持健康，我应该至少空出一点点时间让身体进行修复（比让自己睡一会来得更能接受）。</p> <h2 id="深睡眠与人体生长激素">深睡眠与人体生长激素</h2> <p>关于睡眠的力量，书中多处表述。有一个点我觉得很重要的是：深度睡眠（占睡眠时长的20%左右，但是以Apple Watch帮我监控得到的数据，我可能5%而已[1]，有点可怕）会帮助身体进行修复。</p> <blockquote> <p>美国临床心理学家、睡眠专家迈克尔·J.布利乌斯博士宣称，睡眠的胜利修复功效大多产生于这一阶段，比如生长激素分泌量的增加。人体生长激素是一种能促进新细胞生长和组织的修复、让人体能在日常劳作后获得休整、让人（并让人感到）恢复生机与活力的关键成分，我们都离不开它。</p> </blockquote> <p>这个也是我从来不知道的，如果我知道深度睡眠这么厉害，以我的性格，我应该会尝试去追求一下深度睡眠（这也是我现在的一个小小目标，通过这个小追求让我进一步获得更好的睡眠质量，进一步高效的修复自我，进一步的支撑我在日间有能量做我想做的事情）</p> <h2 id="多相睡眠">多相睡眠</h2> <blockquote> <p>在一个生产力至上的社会中，分段式睡眠似乎纯属浪费时间</p> </blockquote> <p>现在大家基本都是晚上睡觉，可能加个午睡。作者还谈论到，在以前，人类对于多相睡眠是极其自然的。除了午间以外，其实在傍晚的时候，人的睡眠冲动是不断下降的，但是睡眠需求却处于峰值。这点我还蛮有感触的，自从我不午睡之后，我时不时的在6-7点这个时间段感到极为困倦，不论是在开车犯困还是到家躺在沙发上直接睡着都是身体在不断提醒我我应该休息一下（尽管我一直无视这个信号）。</p> <h2 id="总结">总结</h2> <p>如果没有以较为全面科学的方式去重新认识睡眠，我们会了解什么是褪黑素，褪黑素有什么用么？还有可能觉得睡懒觉是有负罪感的。我们也无法认知到睡眠周期和睡眠阶段组成。</p> <p>每个人都能用30年、40年的时光来度过自己的前半生进入中年，然后觉得自己经历很多了，觉得自己可以传授自己的认知给后来者了。这中间的问题就在于你以为你以为的，其实并不是那么一回事，在你认知里它是对的，是真理的，是经过实践的真知。但是或许有一天（不管你还在不在世），有人（可能是你也可能是别人）会质疑你的这个观点，并进一步完善自己的观点传授给下一个人。这个世界就是这么有趣也这么无趣，从贯穿人类史的时空维度上，我们就是在这个模式之下不断重复演绎相同故事的镜像。区别在于，我们建立了这样的体系，我们能保存和传播知识，并有机制能反向推到前人的知识，建立新的知识。</p> <p>我们似乎追求到了更加“正确”的知识。</p> <p>但是这代表了我们的认知水平一代比一代更好么？从通识角度来说，我认为是的。但是人的一生是有限的，精力也是有限的，社会需要的人才是市场化的，这就导致了，知识在某个领域演变得越来越复杂（哪怕不复杂，随时间演变不断堆砌的信息量也会）导致一个人很难能掌握很多领域的知识，因此通才或全才已经演变成专精某个或某几个领域的人才，这也是现在这个社会，尤其是市场化和资本化主导的世界的现状。</p> <p>你，还想用科学的手段重新认识习以为常的事物么？</p> <p>[1]：修订一下，可穿戴设备的统计并不准确，比如根据加速计结合动作判断是深度睡眠还是浅睡眠；真正能提供准确数据的是诸如多导睡眠脑电图和一些头戴式睡眠监测仪等。因此实际上我们可以结合自我的感觉来判断，早晨起来觉得精力充沛的同时Apple Watch显示深度睡眠很少，这个时候应该相信什么呢？</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[我们有很多的认知都来源于代代口述相传和切身感受的经验组成，尤其是对于很多日常中出现的事物，而且这些东西在教育体系中鲜少涉及（部分专业学习中可能会涉及），这会导致一些认知的固化，并且会完全没有意识去翻新陈旧或者错误的认知。]]></summary></entry><entry><title type="html">技术革命中的博弈 / Competing Forces in the Tech Revolution</title><link href="https://ifuryst.github.io/blog/2024/competing-forces-in-the-tech-revolution/" rel="alternate" type="text/html" title="技术革命中的博弈 / Competing Forces in the Tech Revolution"/><published>2024-09-22T13:41:27+00:00</published><updated>2024-09-22T13:41:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/competing-forces-in-the-tech-revolution</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/competing-forces-in-the-tech-revolution/"><![CDATA[<p>人类历史以来有过多次大型的技术革命，也有很多更小一点的技术突破和应用。在这些技术的应用和演进过程中伴随着很多的摩擦碰撞和协商妥协。</p> <p>我们听说过这样的说辞：新的技术出现会导致一些旧的职业消失，但同时也会创造一些新的就业，从长远角度看是对人类有好处的。</p> <p>我们一起来看看这里面的关键点：</p> <ol> <li>首先新技术会导致一些职业消失，这点我觉得毋庸置疑的，尤其是工业革命、互联网这些关键技术的应用会导致很多职业的消失，很多人会因此下岗失业。</li> <li>其次是创造新就业，我觉得这点也是正确的，新的岗位会出现。</li> <li>长远角度看对人类有好处，根据历史来看，似乎确实是这样的，从大的数据角度比如GDP或者社会财富总值来看是符合这个预期的。</li> </ol> <p>但是我们将其组合起来看，是可以看出很多问题的，首先是一些比较直观的问题：</p> <ol> <li>失去工作的人并不会进入到新创造的岗位中。很多人所拥有的知识和技能不足以支持他在岗位消失就找到比现有工作更好的工作，除非她有较好的再学习再教育能力，但是从客观事实来看，大部分人是不具备这个条件的，因素有很多，比如年龄问题，社会层面的保障支撑问题，个人视野层面问题等等。因此从某种角度来看这也是就业摩擦的一种，最终的结果就是这批人进入更差的岗位从事新的工作或者直接丧失就业能力。</li> <li>社会最优并不是个人最优。一个社会进步，从人类跨世代的宏观视角来说，技术的进步从长期来看会带给人类更好的生活，但是这期间可能是丧失了一部分2-3代人的生活。</li> </ol> <p>到这里我们也能看到矛盾所在了。如果掌权者或者拥有较大政治力量的群体的利益依托在那些会被新的技术所威胁的群体之上，那么新的技术的发展必然会受到较大或者完全的限制。反之亦然。</p> <p>因此长期的技术发展取决于很多短期的决策所组成。按照目前的AI应用的角度来看，我们是可以看到很多相关的例子的。AI目前已经发展到一定的程度了，已经几乎到了各行各业都可以从新结合AI重做一遍，这也导致了很多职业开始慢慢消亡，比如我们可以看到以好莱坞编剧和演员为主的创作者群体用罢工抗议来应对AI的应用推广。还有最近引发较多关注和讨论的加州SB1047。还有欧洲在AI层面走在世界前沿的例子。</p> <p>从这些不难看出就是各种利益在博弈。利益受损方必然会捍卫自己的利益，哪怕长远角度看对人类有好处的也不及其剩余的人生保障，这无可厚非。我觉得从客观角度大部分人很难做到从人类宏观视角来舍己为人，这完全不利己，不太符合市场驱动机制发展的社会。反过来看支持技术发展的往往是技术利益既得者以及利益不受损者。前者很好理解，诸如很多技术领域的企业，他们有理由推进技术发展并从中受益；后者也不难理解，利益不受损的人其实我们可以假待为中立的人，但是这些中立的人也会有偏向性，即他们分别会支持两个方向。</p> <p>看明白了这些，在对于一些政策的制定上，我们也可以从这个角度去看待各方参与者，分析他们的利益和观点由来，可能是个不错的观察点，这其中也包括我们自己😶‍🌫️</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[人类历史以来有过多次大型的技术革命，也有很多更小一点的技术突破和应用。在这些技术的应用和演进过程中伴随着很多的摩擦碰撞和协商妥协。]]></summary></entry><entry><title type="html">目标制定、标准衡量和人心管理 / Goal Planning, Performance Assessment, and Team Cohesion</title><link href="https://ifuryst.github.io/blog/2024/goals-metrics-n-team-spirit/" rel="alternate" type="text/html" title="目标制定、标准衡量和人心管理 / Goal Planning, Performance Assessment, and Team Cohesion"/><published>2024-09-17T13:41:27+00:00</published><updated>2024-09-17T13:41:27+00:00</updated><id>https://ifuryst.github.io/blog/2024/goals-metrics-n-team-spirit</id><content type="html" xml:base="https://ifuryst.github.io/blog/2024/goals-metrics-n-team-spirit/"><![CDATA[<p>在做OKR或者目标的制定中，不管是季度还是年度的，本意应是好的，毕竟从企业的角度来看，能让一线的员工也能感知到公司级别的战略或者目标是一件很好的事情。但是在关于目标制定、迭代和最终结果评定以及绩效发放的过程中，有可能会变形。这个问题我思考过几次，现在我稍微有一些想法了。</p> <p>我想探讨的是个人的差异带来的向心力不足的问题，也就是减少团队内部猜忌所带来的的内耗。</p> <p>在一个团队内，通常是存在不同级别的人员的，有初级工程师也会有高级工程，甚至是资深工程师。在这种情况下，每个级别能达成的目标必然是不同的，因为能力、薪资待遇水平的差异，注定了高级别的人员理应产出更多的成果（先不论这些成果的价值），因此在制定目标的时候，最合理的必然是有差异化的难度水平，因为对于低级别的工程师来说，要起完成高级别工程师才能完成的目标，是有些强人所难了，也对他们不公平，因此对于每个级别，甚至是每个人都能有一个专门的目标，会最大化团队的能力。</p> <p>但是这也带来一定的问题：</p> <ol> <li>这就注定了，个人的目标在团队或公司级别的高纬度的目标内的体现有可能是一句话或者压根没体现。</li> <li>团队内除了Leader以外，可能某人对于其他人的目标情况和难易程度（在制定阶段）可能完全不care</li> <li>Leader有可能没有办法面面俱到地帮助每个人审核和把控其目标是否合理，可能只是做到了目标和上级的目标是否一致</li> </ol> <p>上面这些问题会分别带来一些不同的问题：</p> <ol> <li>某些幸运儿会拿到上一层级目标的完整词条，也就是上一层别的目标会落到某个或某几个员工身上，这会让这些人会有更大的压力和动力，相应的会更有价值感；而在上一层级目标中没有体现的人，会走向相反的方向，会更加没有价值感，驱动力可能会更加弱</li> <li>这个在制定目标初期并不会有任何问题，问题可能发生在过程或者结束的时候。因为在每个人的视角来看，可能会觉得别人的目标比自己轻松太多了（不论是主观还是客观），目标和职级不匹配，心生芥蒂，这是危险的种子</li> <li>这我喜欢称之为向上管理的一个例子。其实很多时候完成上级的目标没有问题，问题是你通过什么手段和方式来完成。如果你希望你的团队战斗力很强，那么最好不要草率的对待每个人的目标，尤其这个目标的持续时间比较长的情况下。最好能因人制宜，将目标和个人的意愿或规划做一定程度的匹配，当然这个会消耗管理者较多的时间</li> </ol> <p>我觉得这些问题大多能在前置环节解决，有些在过程中也能调整解决，关键在于能否识别。这里就需要看团队或者公司的文化和氛围是否有对应的机制去接收员工的反馈。不是每个人都会主动对团队或公司的发展出谋划策的，但是要有这样的机制能接收员工的反馈，这样才能知道团队是否出了问题，这有助于某些坏事情在滋生阶段就介入处理的。</p> <p>在目标制定阶段，在确定初版之后，我觉得有一个环节可以有蛮大收益的，让每个人对别人的目标做评价，这样他们可以认真去看别人的目标，这样可以在前置环节就让大家互相知道对方的目标，并且如果可以的话，可以问某个人如果xxx休假了，你可否代替她完成她的目标？一旦这个说法出来之后，这个人对于别人的目标的心态就会有些许变化了，可能就会开始带入自己是主人公的角色去思考，这样有助于大家对于目标制定达成共识。这点其实和敏捷迭代里的点数评估类似，比如某个任务，A需要2D完成，但是B只需要1D完成，这就是能力差异以及目标执行人的可替换性，其实不仅在迭代里可以这样，在目标的制定也是如此，我们不希望某个目标只能由某个人完成，我们其实应该至少保证有2个人以上可以完成某个目标，理想情况下当然是团队内每个人都可以完成任意的目标，但是出于对专业化分工的带来效率最大化的追求，通常是不会这样的，但至少我们可以保证有至少2人能完成某个目标。</p> <p>在目标的制定和规划上，管理人员不能只考虑自己的目标是否能完成，应该充分考虑将团队成员充分发挥起来，整个团队一起完成目标。参与感是一个很重要的东西。这里我想要举个有趣的例子来佐证这个观点：</p> <p>我们在做Scrum迭代的时候，正常是会有一个固定的Scrum master，负责组织站会、规划回顾会之类的敏捷会议。但是我们在实践过程中发现，与其设定一个固定的Scrum Master，不如让人人皆为Scrum Master，也就是轮流制，简单的实践方式是每周（假设迭代冲刺周期是1week）由不同的团队成员来担任Scrum Master。我发现这种方式带来的好处是远远大于前值的，主要集中在这么几点：</p> <ol> <li>每个人都能有机会成长，学会如何转从头到尾主持处理一次完成的敏捷迭代冲刺</li> <li>大家都会以主人公的意识来参与，当轮到别人做Scrum Master的时候你不会在旁边划水或者不怎么爱应答其发出的疑问，因为你知道当Scrum Master的感觉，也知道你提问的时候没人回应的感觉，你也希望下次你做Scrum Master的时候大家能配合你</li> <li>对于团队目标的追踪，你会开始上心，哪怕轮到你一次需要好几周，但是因为你已经开始注意目标的跟进了，你已经锚定了，因此你很容易就会将对应的信息听进去并且评估团队的情况</li> <li>团队内有管理能力的人会慢慢浮出水面，大家都得到了机会，作为管理者你可以很容易的观测到每个人在管理者的角度做事时是怎样的姿态，能帮助管理者更加容易的发现每个人的能力和定位，以及在遇到问题时候要怎样针对性的应对</li> </ol> <p>我并不是倡导一定要走轮流Scrum Master的方式，我只是觉得这种方式值得一试。这个例子说明是想说明如果你希望团队成员都动起来，首先需要让每个人尽可能找到主人翁的意识，这有挺多方法能达到的，我这里仅仅举了个例子。</p> <p>管理中最难的且最重要的永远是人，其次才是产品和利润（来自创业维艰），我觉得前者偏向于因，后两者偏向于果。因此我觉得好的管理是能人尽其才 🫡</p>]]></content><author><name></name></author><category term="opinions"/><category term="thoughts"/><summary type="html"><![CDATA[在做OKR或者目标的制定中，不管是季度还是年度的，本意应是好的，毕竟从企业的角度来看，能让一线的员工也能感知到公司级别的战略或者目标是一件很好的事情。但是在关于目标制定、迭代和最终结果评定以及绩效发放的过程中，有可能会变形。这个问题我思考过几次，现在我稍微有一些想法了。]]></summary></entry></feed>